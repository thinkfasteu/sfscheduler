<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Dienstplan-System Pro</title>
  <style>
    :root {
      --primary-color: #007bff;
      --secondary-color: #677684;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --warning-color: #ffc107;
      --light-bg: #f8f9fa;
      --border-color: #e9ecef;
      --text-dark: #2c3e50;
      --text-light: #fff;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: var(--text-dark);
    }
    .container { max-width: 1600px; margin: 0 auto; background: var(--text-light); border-radius: 20px; box-shadow: 0 25px 50px rgba(0,0,0,0.15); overflow: hidden; }
    .header { background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color: var(--text-light); padding: 30px; text-align: center; }
    .tabs { display: flex; background: var(--light-bg); border-bottom: 1px solid var(--border-color); }
    .tab {
      flex: 1; padding: 20px; text-align: center; background: none; border: none; font-size: 1em; cursor: pointer;
      transition: all 0.3s ease; color: var(--secondary-color); font-weight: 500;
    }
    .tab.active, .tab:hover { color: var(--primary-color); background: #e9ecef; }
    .tab.active { background: var(--primary-color); color: var(--text-light); }
    .tab-content { padding: 30px; }
    .section { display: none; animation: fadeIn 0.5s ease-in-out; }
    .section.active { display: block; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .controls, .form-group { margin-bottom: 25px; }
    .form-group label { display: block; margin-bottom: 8px; font-weight: 600; }
    .form-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px; }
    .availability-controls { grid-template-columns: 1fr 1fr 1fr auto; align-items: end; }
    input, select, button {
      padding: 12px 16px; border: 2px solid var(--border-color); border-radius: 8px;
      font-size: 1em; transition: all 0.3s ease; width: 100%;
    }
    .btn { background: var(--primary-color); color: var(--text-light); border: none; cursor: pointer; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
    .btn-success { background: var(--success-color); }
    .btn-danger { background: var(--danger-color); }
    .btn-secondary { background: var(--secondary-color); }
    #cancelEditBtn, #preference-group { display: none; }

    .staff-card { background: var(--light-bg); padding: 20px; border-radius: 12px; border-left: 5px solid var(--primary-color); }
    .schedule-table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9em; }
    .schedule-table th, .schedule-table td { padding: 12px 8px; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: top;}
    .schedule-table th { background: #343a40; color: var(--text-light); }
    .schedule-table tr.weekend { background: #f0f8ff; }
    .schedule-table tr.holiday { background: #fff3cd; font-weight: bold; border-left: 4px solid var(--warning-color); }
    /* Availability table row highlights */
    .avail-row.is-weekend { background: #f0f8ff; }
    .avail-row.is-holiday { background: #fff3cd; border-left: 4px solid var(--warning-color); }

    /* Disabled cell for shifts that don't apply on a given day */
    .na-cell {
     opacity: 0.5;
     text-align: center;
     font-style: italic;
     padding: 8px 0;
    }
    .day-flag {
     font-size: 0.8em;
     margin-left: 6px;
     padding: 2px 6px;
     border-radius: 10px;
     background: #e9ecef;
    }

    .staff-assignment {
      padding: 4px 8px; border-radius: 15px; margin: 2px; display: inline-flex; align-items: center; gap: 6px;
      font-size: 0.95em; background: #e3f2fd; color: #1565c0;
    }
    .badge { font-size: 0.75em; background: #ffeeba; color: #8a6d3b; padding: 2px 6px; border-radius: 10px; }
    .swap-btn { cursor: pointer; margin-left: 5px; font-weight: bold; }
    .validation-warning { color: var(--danger-color); cursor: pointer; font-weight: bold; margin-left: 4px; }

    .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); }
    .modal-content { background-color: #fefefe; margin: 10% auto; padding: 25px; border: 1px solid #888; width: 80%; max-width: 600px; border-radius: 15px; }
    .modal-content h3 { margin-bottom: 20px; }
    #holidaysModalContent { max-height: 400px; overflow-y: auto; }
    .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
/* ‚Äî‚Äî Header branding patch (non-breaking) ‚Äî‚Äî */
.header .header-brand {
  display: inline-flex;          /* inline so it respects the .header‚Äôs center alignment */
  align-items: center;
  gap: 12px;
  text-align: left;              /* keep text tidy next to the logo */
}
.header .app-logo {
  height: 48px;                  /* tweak to taste */
  width: auto;
}
.header .app-title h1 {
  margin: 0;
  line-height: 1.2;
}
.header .app-title p {
  margin: 2px 0 0 0;
}

/* Stack nicely on small screens */
@media (max-width: 600px) {
  .header .header-brand {
    flex-direction: column;
    gap: 6px;
    text-align: center;
  }
}
/* Manual search spacing tweaks */
#candidateSelect { min-width: 220px; }
#toastContainer {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 2000;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.toast {
  background: #343a40;
  color: #fff;
  padding: 10px 14px;
  border-radius: 8px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.15);
  opacity: 0;
  transform: translateY(10px);
  animation: toast-in .18s ease-out forwards, toast-out .22s ease-in 2.6s forwards;
  font-size: 0.95em;
}
.toast.success { background: #28a745; }
.toast.error   { background: #dc3545; }
.toast.info    { background: #17a2b8; }

@keyframes toast-in   { to { opacity: 1; transform: translateY(0); } }
@keyframes toast-out  { to { opacity: 0; transform: translateY(10px); } }
  </style>
</head>
<body>
    <div class="container">
      <div class="header">
    <div class="header-brand">
      <img src="logo-sportfabrik.jpg" alt="Sportfabrik Logo" class="app-logo" />
      <div class="app-title">
        <h1>Dienstplan-System Pro</h1>
        <p>Schichtplanung f√ºr SPORTFABRIK Front-Desk</p>
      </div>
    </div>
  </div>


    <div class="tabs">
  <button class="tab active" onclick="showTab(event, 'staff')">Personalverwaltung</button>
  <button class="tab" onclick="showTab(event, 'availability')">Verf√ºgbarkeiten</button>
  <button class="tab" onclick="showTab(event, 'schedule')">Dienstplan</button>
  <button class="tab" onclick="showTab(event, 'vacation')">Urlaub</button>
  <button class="tab" onclick="showTab(event, 'otherstaff')">Weitere Mitarbeitende</button>
  <button class="tab" onclick="showTab(event, 'reports')">Berichte</button>
  <button class="tab" onclick="showTab(event, 'log')">Protokoll</button>
 </div>

  <div class="tab-content">
¬† ¬† ¬† ¬† ¬† ¬† <div id="staff-tab" class="section active">
¬† ¬† ¬† ¬† <h2>Personalverwaltung</h2>
¬† ¬† ¬† ¬† <div class="form-group staff-card">
        <h3 id="staffFormTitle">Neue Arbeitskraft hinzuf√ºgen</h3>
        <input type="hidden" id="staffIdToEdit">
        <div class="form-row">
          <input type="text" id="staffName" placeholder="Name" />
          <select id="staffType" onchange="togglePreferenceField()">
            <option value="minijob">Minijobber/in (538‚Ç¨)</option>
            <option value="student">Werkstudent/in</option>
            <option value="permanent">Festangestellt</option>
          </select>
          <input type="number" id="contractHours" placeholder="Vertragsstunden/Woche" />
          <input type="number" id="typicalWorkdays" placeholder="Typische Arbeitstage/Woche" />
        </div>
        <div id="preference-group" class="form-row">
          <div>
            <label>Bevorzugter Schichttyp (Festangestellte)</label>
            <select id="staffPreference">
              <option value="none">Keine Pr√§ferenz</option>
              <option value="early">Fr√ºhschicht bevorzugt</option>
              <option value="midday">Mittagschicht bevorzugt</option>
              <option value="evening">Abendschicht bevorzugt</option>
            </select>
          </div>
        </div>

        <div class="form-row">
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="weekendPreference" />
            <label for="weekendPreference">Bevorzugt Wochenendschichten (alle Mitarbeitertypen)</label>
          </div>
        </div>

        <!-- PLACEHOLDER: Alternative Weekend Days (currently disabled)
        TODO: Uncomment when alternative weekend functionality is needed
        <div id="alternative-weekend-group" class="form-row" style="display: none;">
          <div>
            <label>Alternative Wochenendtage (f√ºr Wochenend-bevorzugende Festangestellte)</label>
            <div style="display: flex; gap: 10px; margin-top: 5px;">
              <select id="alternativeWeekendDay1">
                <option value="">Erster Ruhetag</option>
                <option value="1">Montag</option>
                <option value="2">Dienstag</option>
                <option value="3">Mittwoch</option>
                <option value="4">Donnerstag</option>
                <option value="5">Freitag</option>
              </select>
              <select id="alternativeWeekendDay2">
                <option value="">Zweiter Ruhetag</option>
                <option value="1">Montag</option>
                <option value="2">Dienstag</option>
                <option value="3">Mittwoch</option>
                <option value="4">Donnerstag</option>
                <option value="5">Freitag</option>
              </select>
            </div>
            <small style="color: #666;">Zwei aufeinanderfolgende Wochentage, an denen √úberstunden-Zustimmung erforderlich ist</small>
          </div>
        </div>
        -->

        <h4>Urlaubszeitr√§ume</h4>
        <div class="form-row" style="align-items: flex-end;">
          <div><label>Von:</label><input type="date" id="vacationStart" /></div>
          <div><label>Bis:</label><input type="date" id="vacationEnd" /></div>
          <button class="btn btn-secondary" onclick="addVacationPeriod()">Urlaub hinzuf√ºgen</button>
        </div>
        <ul id="vacationList"></ul>

        <h4>Krankheitszeitr√§ume</h4>
        <div class="form-row" style="align-items: flex-end;">
          <div><label>Von:</label><input type="date" id="illnessStart" /></div>
          <div><label>Bis:</label><input type="date" id="illnessEnd" /></div>
          <button class="btn btn-secondary" onclick="addIllnessPeriod()">Krankmeldung hinzuf√ºgen</button>
        </div>
        <ul id="illnessList"></ul>

        <div class="form-row">
          <button id="saveStaffBtn" class="btn" onclick="addStaff()">Arbeitskraft speichern</button>
          <button id="cancelEditBtn" class="btn btn-secondary" onclick="resetStaffForm()">Abbrechen</button>
        </div>
      </div>
      <div id="staffList" class="form-row"></div>

      <!-- Overtime Requests Section -->
      <div class="staff-card" style="margin-top: 20px;">
        <h3>Wochenend-√úberstunden Anfragen</h3>
        <p style="color: #6c757d;">Anfragen f√ºr Wochenendschichten von Festangestellten (nur bei unbesetzbaren Schichten)</p>
        <div id="overtimeRequestsList"></div>
      </div>

    </div>

    <div id="vacation-tab" class="section">
      <h2>Urlaubsverwaltung</h2>
      <div class="controls form-row" style="grid-template-columns: 200px;">
          <select id="vacationYearSelect" onchange="displayVacationLedger()"></select>
      </div>
      <div id="vacationLedgerContent"></div>
    </div>
<!-- OTHER STAFF (non-reception) -->
<div id="otherstaff-tab" class="section">
  <h2>Weitere Mitarbeitende (nur Urlaube)</h2>
  <div class="form-group staff-card">
    <h3 id="otherStaffFormTitle">Mitarbeitende hinzuf√ºgen</h3>
    <input type="hidden" id="otherStaffIdToEdit">
    <div class="form-row">
      <input type="text" id="otherStaffName" placeholder="Name" />
    </div>
    <h4>Urlaubszeitr√§ume</h4>
    <div class="form-row" style="align-items: flex-end;">
      <div><label>Von:</label><input type="date" id="otherVacationStart" /></div>
      <div><label>Bis:</label><input type="date" id="otherVacationEnd" /></div>
      <button class="btn btn-secondary" onclick="addOtherVacationPeriod()">Urlaub hinzuf√ºgen</button>
    </div>
    <ul id="otherVacationList"></ul>
    <div class="form-row">
      <button id="saveOtherStaffBtn" class="btn" onclick="addOtherStaff()">Speichern</button>
      <button id="cancelOtherEditBtn" class="btn btn-secondary" onclick="resetOtherStaffForm()" style="display:none;">Abbrechen</button>
    </div>
  </div>
  <div id="otherStaffList" class="form-row"></div>
</div>


      <!-- AVAILABILITY -->
      <div id="availability-tab" class="section">
        <h2>Verf√ºgbarkeiten / Freiw√ºnsche</h2>
        <p style="margin:10px 0;">
         <span class="day-flag">Wochenende</span>
         <span class="day-flag" style="margin-left:8px;">Feiertag</span>
         <span class="day-flag" style="margin-left:8px; background:#ffe8e8;">‚Äû‚Äî‚Äú = nicht anwendbare Schicht</span>
        </p>

      <div class="controls form-row availability-controls">
          <div>
            <label>Mitarbeiter ausw√§hlen:</label>
            <select id="availabilityStaffSelect" onchange="handleAvailabilityDisplay()"></select>
          </div>
          <div>
            <label>Monat:</label>
            <select id="availabilityMonth" onchange="handleAvailabilityDisplay()"></select>
          </div>
          <button class="btn btn-secondary" onclick="showHolidaysPopup()">Feiertage</button>
        </div>
        <div id="availabilityForm">
          <p>Bitte Mitarbeiter und Monat ausw√§hlen.</p>
        </div>
    <!-- Manual search & replacement -->
    <div class="staff-card" style="margin-top:18px;">
      <h3>Einsatz-Suche & Ersatz</h3>
      <div class="form-row" style="grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));">
        <div>
          <label>Datum</label>
          <input type="date" id="replaceDate" onchange="updateShiftOptionsForDate()" />
        </div>
        <div>
           <label>Schicht</label>
          <select id="replaceShift" disabled></select>
        </div>
        <div>
           <label>&nbsp;</label>
           <button class="btn btn-secondary" onclick="findCandidates()">Verf√ºgbare Personen suchen</button>
        </div>
      </div>
        <div>
          <label>&nbsp;</label>
          <label style="display:flex;align-items:center;gap:6px;">
            <input type="checkbox" id="showPermanentOvertimeCandidates" />
            Festangestellte zeigen (√úberstunden)
          </label>
        </div>


  <div id="currentAssignmentInfo" style="margin:8px 0; color:#6c757d;"></div>

  <div class="form-row" style="grid-template-columns: 2fr 1fr 1fr;">
    <div>
      <label>Ergebnis</label>
      <select id="candidateSelect"></select>
    </div>
    <div>
      <label>&nbsp;</label>
      <button class="btn btn-success" onclick="applyManualAssignment('assign')">In Plan eintragen</button>
    </div>
    <div>
      <label>&nbsp;</label>
      <button class="btn btn-danger" onclick="applyManualAssignment('sickReplace')">Krank & ersetzen</button>
    </div>
  </div>
  <small style="color:#6c757d;">Hinweis: Es werden nur f√ºr den Tag zul√§ssige Schichten angeboten (Wochenende/Feiertag/werktags). Zuweisungen werden automatisch validiert.</small>
</div>
      </div>

      <!-- SCHEDULE -->
      <div id="schedule-tab" class="section">
        <h2>Dienstplan</h2>
        <div class="controls form-row" style="align-items: center; grid-template-columns: 2fr 1fr 1fr;">
          <select id="scheduleMonth" onchange="onScheduleMonthChange()"></select>
          <button class="btn btn-success" onclick="generateSchedule()">Dienstplan erstellen</button>
          <button class="btn btn-danger" onclick="clearSchedule()">Plan l√∂schen</button>
        </div>
       <!-- Werkstudent Monatsausnahme Toggle -->
       <div class="controls" style="display:inline-flex;align-items:center;gap:6px;">
         <input type="checkbox" id="wsTempExceptionToggle" onchange="toggleStudentTempException()" />
         <label for="wsTempExceptionToggle">Kurzfristige Ausnahme zulassen (Werkstudent) ‚Äì f√ºr ausgew√§hlten Monat</label>
       </div>

       <!-- Student Fairness Toggle -->
       <div class="controls" style="display:inline-flex;align-items:center;gap:6px;">
         <input type="checkbox" id="studentFairnessToggle" onchange="toggleStudentFairness()" checked />
         <label for="studentFairnessToggle">Fairness-Modus: Gew√ºnschte Arbeitstage respektieren (Werkstudenten)</label>
       </div>


        <div class="controls form-row" style="justify-content: flex-start;">
          <div style="max-width: 200px;">
            <button class="btn" onclick="exportSchedule('csv')">CSV Export</button>
          </div>
          <div style="max-width: 200px;">
            <button class="btn" onclick="exportSchedule('pdf')">PDF Export</button>
          </div>
        </div>
        <div id="scheduleContent" style="overflow-x: auto;"></div>
      </div>

      <!-- REPORTS -->
      <div id="reports-tab" class="section">
        <h2>Berichte</h2>
        <div class="controls form-row">
          <select id="reportsMonth"></select>
          <button class="btn" onclick="generateReport()">Bericht laden</button>
        </div>
        <div id="reportsContent"></div>
      </div>

      <!-- LOG -->
      <div id="log-tab" class="section">
        <h2>√Ñnderungsprotokoll</h2>
        <div id="logContent" style="max-height: 500px; overflow-y: auto;"></div>
      </div>
    </div>
  </div>

  <!-- Swap Modal -->
  <div id="swapModal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="closeModal('swapModal')">&times;</span>
      <h3 id="swapModalTitle">Schicht bearbeiten</h3>
      <div class="form-group">
        <label for="swapStaffSelect">Neue Person:</label>
        <select id="swapStaffSelect"></select>
      </div>
      <div class="form-row">
        <button class="btn btn-success" onclick="executeSwap()">Schicht tauschen</button>
        <button class="btn btn-danger" onclick="reportSick()">Als Krank melden</button>
      </div>
    </div>
  </div>

  <!-- Holidays Modal -->
  <div id="holidaysModal" class="modal">
    <div class="modal-content">
      <span class="close-btn" onclick="closeModal('holidaysModal')">&times;</span>
      <h3 id="holidaysModalTitle">Gesetzliche Feiertage</h3>
      <div id="holidaysModalContent"></div>
    </div>
  </div>

  <!-- Overtime Consent Modal -->
  <div id="overtimeConsentModal" class="modal">
    <div id="overtimeConsentContent"></div>
  </div>

 <template id="staff-card-template">
    <div class="staff-card">
      <h4 data-name></h4>
      <p>Typ: <span data-type></span></p>
      <p>Vertragsstunden/Woche: <span data-contract-hours></span></p>
      <p>Typische Arbeitstage/Woche: <span data-workdays></span></p>
      <div data-preference-container style="display: none;">
        <p>Pr√§ferenz: <span data-preference></span></p>
      </div>
      <h5>Urlaube:</h5>
      <ul data-vacation-list></ul>
      <div class="form-row" style="margin-top: 15px;">
        <button class="btn btn-secondary" data-edit-btn>Bearbeiten</button>
        <button class="btn btn-danger" data-delete-btn>Entfernen</button>
      </div>
    </div>
  </template>

  <template id="other-staff-card-template">
    <div class="staff-card">
      <h4 data-name></h4>
      <h5>Urlaube:</h5>
      <ul data-vacation-list></ul>
      <div class="form-row" style="margin-top: 15px;">
        <button class="btn btn-secondary" data-edit-btn>Bearbeiten</button>
        <button class="btn btn-danger" data-delete-btn>Entfernen</button>
      </div>
    </div>
  </template>

  <template id="vacation-li-template">
    <li>
      <span data-dates></span>
      <button class="btn-danger" style="width:auto; padding: 2px 8px; margin-left: 8px; border-radius: 4px;">X</button>
    </li>
  </template>

  <template id="carryover-box-template">
    <div class="staff-card" style="margin-top:16px;">
      <h4>Stunden√ºbertrag (Vormonat ‚Üí <span data-month></span>)</h4>
      <p style="margin:6px 0;color:#6c757d;">
        Ein positiver Wert erh√∂ht das Monatsziel (z.B. +3h), ein negativer Wert verringert es (z.B. -3h).
      </p>
      <div data-overtime-info style="display: none; margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px;">
        <p style="margin: 0; color: #155724; font-weight: bold;">
          üïí √úberstunden-Guthaben: <span data-overtime-hours></span>h
        </p>
        <p style="margin: 5px 0 0 0; color: #6c757d; font-size: 0.9em;">
          √úberstunden werden automatisch vom Monatsziel abgezogen.
        </p>
      </div>
      <div class="form-row" style="grid-template-columns: 1fr auto auto;">
        <div>
          <label data-input-label>Manueller √úbertrag</label>
          <input type="number" step="0.25" data-carryover-input />
        </div>
        <div>
          <label>&nbsp;</label>
          <button class="btn btn-info" data-auto-btn>
            Auto (<span data-auto-value></span> h)
          </button>
        </div>
        <div>
          <label>&nbsp;</label>
          <button class="btn btn-secondary" data-save-btn>Speichern</button>
        </div>
      </div>
    </div>
  </template>

  <template id="availability-permanent-template">
    <div class="staff-card">
      <h4>Freiw√ºnsche f√ºr: <span data-staff-name></span></h4>
      <p>Festangestellte arbeiten normalerweise Fr√ºh- und Mittagsschichten (Mo‚ÄìFr). Abendschichten sind m√∂glich, werden aber nur bei Bedarf eingeteilt.</p>
      <table class="schedule-table">
        <thead>
          <tr>
            <th>Datum</th>
            <th>Fr√ºhschicht</th>
            <th>Mittagschicht</th>
            <th>Abendschicht*</th>
            <th>Sp√§tschicht*</th>
          </tr>
        </thead>
        <tbody data-table-body>
        </tbody>
      </table>
      <p style="font-size: 0.9em; color: #6c757d; margin-top: 10px;">
        * Abend-/Sp√§tschichten werden nur eingeteilt, wenn keine anderen Mitarbeiter verf√ºgbar sind.<br>
        <span style="color: #28a745;">‚úì "freiwillig"</span> = Reduziert die Abendschicht-Strafe f√ºr diesen Tag (h√∂here Priorit√§t)
      </p>
    </div>
  </template>

  <template id="availability-general-template">
    <div class="staff-card">
      <h4>Verf√ºgbarkeit f√ºr: <span data-staff-name></span></h4>
      <table class="schedule-table">
        <thead>
          <tr>
            <th>Tag</th>
            <!-- Shift headers will be dynamically added -->
          </tr>
        </thead>
        <tbody data-table-body>
        </tbody>
      </table>
    </div>
  </template>

  <template id="availability-row-template">
    <tr data-row-class>
      <td data-date-cell></td>
      <!-- Shift cells will be dynamically added -->
    </tr>
  </template>



  <template id="staff-assignment-template">
    <span class="staff-assignment">
      <span data-staff-name></span>
      <span class="badge" data-badge style="display: none;"></span>
      <span class="swap-btn" data-swap-btn>üîÑ</span>
      <span class="validation-warning" data-warning style="display: none;">‚ö†Ô∏è</span>
    </span>
  </template>

  <template id="reports-overview-template">
    <h3>Stunden√ºbersicht f√ºr <span data-month></span></h3>
    <table class="schedule-table">
      <thead>
        <tr>
          <th>Mitarbeiter</th>
          <th>Typ</th>
          <th>Stunden</th>
          <th>Verdienst (ca.)</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody data-table-body>
      </tbody>
    </table>
  </template>

  <template id="reports-row-template">
    <tr>
      <td data-name></td>
      <td data-type></td>
      <td data-hours></td>
      <td data-earnings></td>
      <td data-status></td>
    </tr>
  </template>

  <template id="werkstudent-overview-template">
    <h3 style="margin-top:20px;">Werkstudent Wochen√ºbersicht</h3>
    <table class="schedule-table">
      <thead>
        <tr>
          <th>Name</th>
          <th>KW</th>
          <th>Stunden</th>
          <th>WE/Nacht-Anteil %</th>
          <th>Ausnahme (WS)</th>
        </tr>
      </thead>
      <tbody data-table-body>
      </tbody>
    </table>
  </template>

  <template id="werkstudent-row-template">
    <tr>
      <td data-name></td>
      <td data-week></td>
      <td data-total></td>
      <td data-ratio></td>
      <td data-exception></td>
    </tr>
  </template>

  <template id="vacation-ledger-template">
    <table class="schedule-table">
      <thead>
        <tr>
          <th>Mitarbeiter</th>
          <th>Urlaubsanspruch</th>
          <th>Urlaub genommen (manuell)</th>
          <th>Urlaub geplant</th>
          <th>Urlaub verbleibend</th>
          <th>Krank gemeldet (Jahr)</th>
          <th>Aktion</th>
        </tr>
      </thead>
      <tbody data-table-body>
      </tbody>
    </table>
  </template>

  <template id="vacation-ledger-row-template">
    <tr>
      <td data-staff-info></td>
      <td data-allowance></td>
      <td data-taken-input></td>
      <td data-planned></td>
      <td data-remaining></td>
      <td data-sick-days></td>
      <td data-action-button></td>
    </tr>
  </template>

  <template id="holidays-table-template">
    <table class="schedule-table">
      <thead>
        <tr>
          <th>Datum</th>
          <th>Feiertag</th>
        </tr>
      </thead>
      <tbody data-table-body>
      </tbody>
    </table>
  </template>

  <template id="log-table-template">
    <table class="schedule-table">
      <thead>
        <tr>
          <th>Zeitstempel</th>
          <th>Aktion</th>
        </tr>
      </thead>
      <tbody data-table-body>
      </tbody>
    </table>
  </template>

  <template id="overtime-consent-modal">
    <div class="modal-content">
      <span class="close-btn" data-close-btn>&times;</span>
      <h3>Wochenend-√úberstunden Anfrage</h3>
      <div class="form-group">
        <p><strong>Mitarbeiter:</strong> <span data-staff-name></span></p>
        <p><strong>Datum:</strong> <span data-date></span></p>
        <p><strong>Schicht:</strong> <span data-shift-info></span></p>
        <p><strong>Grund:</strong> <span data-replacement-reason></span></p>
        <p style="color: #dc3545; font-weight: bold;">
          ‚ö†Ô∏è Diese Wochenendschicht wird als √úberstunden gewertet und dem Monatsziel gutgeschrieben.
        </p>
        <p style="color: #6c757d; font-size: 0.9em;">
          Hinweis: √úberstunden-Anfragen erfolgen nur bei unbesetzbaren Schichten.
        </p>
      </div>
      <div class="form-row">
        <button class="btn btn-success" data-consent-btn>Zustimmung erteilen</button>
        <button class="btn btn-danger" data-decline-btn>Ablehnen</button>
        <button class="btn btn-secondary" data-cancel-btn>Abbrechen</button>
      </div>
    </div>
  </template>

  <template id="overtime-request-item">
    <div class="staff-card" style="border-left-color: #ffc107;">
      <h4>√úberstunden-Anfrage</h4>
      <p><strong>Datum:</strong> <span data-date></span></p>
      <p><strong>Schicht:</strong> <span data-shift-info></span></p>
      <p><strong>Status:</strong> <span data-status></span></p>
      <div class="form-row" data-action-buttons>
        <button class="btn btn-success" data-consent-btn>Zustimmen</button>
        <button class="btn btn-danger" data-decline-btn>Ablehnen</button>
      </div>
    </div>
  </template>

  <!-- Scripts (PDF export libs) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>

<script>
/*
 * ===================== STAFF SCHEDULER PRO - TABLE OF CONTENTS =====================
 *
 * 1. CONFIG & STATE - Application configuration and global variables
 * 2. PERSISTENCE / LOG - Data saving, loading, and audit logging
 * 3. TEMPLATE UTILITIES - HTML template management helpers
 * 4. MEMORY MANAGEMENT - Memory monitoring and cleanup utilities
 * 5. INIT / ROUTING - Application initialization and tab routing
 * 6. DATE UTILS - Date formatting and manipulation functions
 * 7. HOLIDAYS - Holiday fetching and management
 * 8. ALTERNATIVE WEEKEND FUNCTIONALITY (PLACEHOLDER) - Future fair work-life balance system
 * 9. OVERTIME CONSENT SYSTEM - Permanent employee overtime management
 * 10. VOLUNTARY EVENING AVAILABILITY - Evening shift preference system
 * 11. STAFF MGMT - Staff creation, editing, and management
 * 12. OTHER STAFF - Non-reception staff management
 * 13. AVAILABILITY - Staff availability tracking and display
 * 14. MONTHLY TARGETS - Contract hour calculations for all employee types
 * 15. MANUAL SEARCH & REPLACEMENT - Manual shift assignment tools
 * 16. STUDENT WEEKDAY DAYTIME TRACKING - Student term-aware scheduling limits
 * 17. WEEKEND DISTRIBUTION TRACKING - Fair weekend assignment system
 * 18. SCHEDULER - Main scheduling algorithm with fairness constraints
 * 19. VALIDATION - Schedule validation, warnings, and compliance checks
 * 20. SCHEDULE DISPLAY - Schedule rendering and user interface
 * 21. REPORTS - Monthly reports and metrics generation
 * 22. MODALS / EXPORTS / LOG - UI modals, PDF export, and logging display
 * 23. SWAP FUNCTIONALITY - Shift swapping between employees
 * 24. WS TOGGLE - Werkstudent exception toggle interface
 *
 * Total Lines: ~5,067
 * Key Features: Fair scheduling, legal compliance, weekend preferences, University term awareness (Werkstudenten)
 */

/* ===================== CONFIG & STATE ===================== */
const APP_CONFIG = {
  // === Monthly targeting (global) ===
  DEFAULT_MONTH_TOLERANCE: 4,  // Fallback if role not listed
  MONTH_TOLERANCE_BY_ROLE: {
    minijob:   4,
    student:   4,
    permanent: 2
    },
  FLOAT_PRECISION_OFFSET: 1e-6, //
  EVENING_OPTIONAL_DAYS: [2, 4], // Tue, Thu

  // Shift priority levels for hour conservation
  CRITICAL_SHIFTS: ['early', 'midday', 'closing'], // Must be filled on weekdays
  OPTIONAL_SHIFTS: ['evening'], // Can be skipped on Tue/Thu to save hours
  WEEKEND_SHIFTS_CRITICAL: true, // All weekend shifts are critical

  // Hour conservation settings
  HOUR_CONSERVATION_ENABLED: true,
  HOUR_CONSERVATION_THRESHOLD: 1.5, // Hours per remaining day threshold for conservation

  // Fairness settings
  FAIRNESS_ENABLED: true,
  STUDENT_MAX_EXTRA_DAYS_PER_WEEK: 1,
  TYPICAL_DAYS_PENALTY: 200, // Base penalty for exceeding typical workdays
  EXTRA_DAY_PENALTY: 100, // Additional penalty per extra day worked
  FAIRNESS_OVERRIDE_THRESHOLD: 0.5, // Allow override if monthly target <50% achieved
  MAX_EXTRA_DAYS_ALLOWED: 1,
  MAX_EXTRA_DAYS_HARD_CAP: 2,
  SECOND_EXTRA_DAY_SHIFT_KEY: 'evening',

  // Student weekday daytime limits (during term)
  STUDENT_WEEKDAY_DAYTIME_ENABLED: true,
  STUDENT_MAX_WEEKDAY_DAYTIME_SHIFTS: 1, // Max early/midday shifts per week during term
  STUDENT_WEEKDAY_DAYTIME_PENALTY: 300, // Heavy penalty for exceeding weekday daytime limit

  // Student strategic preferences (configurable weights)
  STUDENT_WEEKEND_BONUS: 60, // Bonus for weekend shifts
  STUDENT_EVENING_BONUS: 80, // Bonus for evening shifts
  STUDENT_WEEKDAY_DAYTIME_PENALTY_PREF: -50, // Preference penalty for weekday daytime

  // Student exception tracking
  STUDENT_MAX_EXCEPTION_WEEKS_PER_TERM: 2, // Max automatic >20h exception weeks per term
  STUDENT_EXCEPTION_REQUIRES_CRITICAL_SHIFT: true, // Only allow auto exception for critical shifts

  // Weekend saturation (prevent Sat+Sun for same staff)
  WEEKEND_SATURATION_PENALTY: 250, // Heavy penalty when staff already works the other day of the weekend

  // Academic term configuration (Hessen universities)
  ACADEMIC_TERM_CONFIG: {
    // Winter semester: October 1 - March 31 (next year)
    WINTER_START_MONTH: 10, // October
    WINTER_START_DAY: 1,
    WINTER_END_MONTH: 3, // March (next year)
    WINTER_END_DAY: 31,

    // Summer semester: April 1 - September 30
    SUMMER_START_MONTH: 4, // April
    SUMMER_START_DAY: 1,
    SUMMER_END_MONTH: 9, // September
    SUMMER_END_DAY: 30,

    // Lecture periods (stricter limits during these times)
    WINTER_LECTURE_START: { month: 10, day: 15 }, // Mid-October
    WINTER_LECTURE_END: { month: 2, day: 15 }, // Mid-February (next year)
    SUMMER_LECTURE_START: { month: 4, day: 15 }, // Mid-April
    SUMMER_LECTURE_END: { month: 7, day: 15 } // Mid-July
  },

  // Weekend distribution settings (applies to minijob and student employees only)
  WEEKEND_DISTRIBUTION_ENABLED: true,
  MIN_WEEKENDS_PER_MONTH: 1, // Minimum weekends each non-permanent employee must work
  MAX_WEEKENDS_WITHOUT_PREFERENCE: 2, // Max weekends for non-preferring non-permanent employees
  WEEKEND_PREFERENCE_BONUS: 50, // Bonus for employees who prefer weekends (all types)
  WEEKEND_FAIRNESS_PENALTY: 100, // Penalty for unfair weekend distribution (non-permanent only)

  // Permanent employee weekend preference system
  // - If weekendPreference: true, weekend shifts count as regular hours (not overtime)
  // - If weekendPreference: false/undefined, weekend shifts require overtime consent
  // - Weekend-preferring permanent employees get positive scoring for weekend shifts
  // - Monthly targets include weekend days for weekend-preferring employees

  // Alternative weekend functionality (PLACEHOLDER - currently disabled)
  // TODO: Enable when weekend-preferring employees need guaranteed rest days
  ALTERNATIVE_WEEKEND_ENABLED: false, // Set to true to activate alternative weekend functionality
  ALTERNATIVE_WEEKEND_OVERTIME_PENALTY: 100, // Penalty for scheduling on alternative weekend days
  ALTERNATIVE_WEEKEND_REQUIRES_CONSENT: true, // Whether alternative weekend work requires overtime consent

  FULL_TIME_VACATION_DAYS: 30, // Annual vacation days for a 5-day/week employee

  MINIJOB_MAX_EARNING: 556,
  // Optional per-person override in future: use (staff.hourlyWage ?? APP_CONFIG.MINIJOB_HOURLY_WAGE)
  MINIJOB_HOURLY_WAGE: 13.50,

  WERKSTUDENT_MAX_HOURS: 20,
  WERKSTUDENT_EXCEPTION_ENABLED: true,
  WERKSTUDENT_EXCEPTION_NIGHTWE_RATIO: 0.5, // >=50% WE or closing hours unlock >20h

  HOLIDAY_API_STATE: 'HE',
  UNDESIRABLE_SHIFTS: ['closing', 'weekend-early', 'weekend-late', 'evening'],
  MIN_REST_HOURS: 11,
  MAX_CONSECUTIVE_DAYS: 6,

  PERMANENT_HOURS_TOLERANCE: 4,     // weekly ¬±4h


  // Minijob steering (weekly ~10h)
  MINIJOB_TARGET_WEEK_HOURS: 10,
  MINIJOB_MAX_WEEK_HOURS: 15, // Hard weekly limit for legal compliance
  MINIJOB_WEEK_TOLERANCE: 1.5,
  MINIJOB_STEER_PENALTY: 6,
  MINIJOB_THIRD_SHIFT_PENALTY: 50,
  MINIJOB_TOPUP_BONUS: 35
};

let staffData = JSON.parse(localStorage.getItem('staffData')) || [];
let availabilityData = JSON.parse(localStorage.getItem('availabilityData')) || {};
let scheduleData = JSON.parse(localStorage.getItem('scheduleData')) || {};
let holidays = JSON.parse(localStorage.getItem('holidays')) || {};
let auditLog = JSON.parse(localStorage.getItem('auditLog')) || [];
let tempVacationPeriods = [];
let tempIllnessPeriods = [];
let studentTempException = JSON.parse(localStorage.getItem('studentTempException')) || {}; // { 'YYYY-MM': true }
let otherStaffData = JSON.parse(localStorage.getItem('otherStaffData')) || [];
let tempOtherVacations = [];
let carryoverByStaffAndMonth = JSON.parse(localStorage.getItem('carryoverByStaffAndMonth')) || {}; // { "YYYY-MM": { [staffId]: number } }
let monthHoursCache = JSON.parse(localStorage.getItem('monthHoursCache')) || {};                  // { "YYYY-MM": { [staffId]: hours } }
let vacationLedger = JSON.parse(localStorage.getItem('vacationLedger')) || {}; // { [year]: { [staffId]: { allowance: number, taken: number } } }
let permanentOvertimeConsent = JSON.parse(localStorage.getItem('permanentOvertimeConsent')) || {}; // { [staffId]: { [dateStr]: { [shiftKey]: 'requested'|'consented'|'declined' } } }
let overtimeCredits = JSON.parse(localStorage.getItem('overtimeCredits')) || {}; // { "YYYY-MM": { [staffId]: hours } }
let voluntaryEveningAvailability = JSON.parse(localStorage.getItem('voluntaryEveningAvailability')) || {}; // { [staffId]: { [dateStr]: { [shiftKey]: boolean } } }
let weekendAssignments = JSON.parse(localStorage.getItem('weekendAssignments')) || {}; // { month: { staffId: weekendCount } }
let studentWeekdayDaytimeShifts = JSON.parse(localStorage.getItem('studentWeekdayDaytimeShifts')) || {}; // { month: { staffId: { weekNum: count } } }
let studentExceptionWeeks = JSON.parse(localStorage.getItem('studentExceptionWeeks')) || {}; // { term: { staffId: weekCount } }
let academicTermCache = JSON.parse(localStorage.getItem('academicTermCache')) || {}; // { dateStr: { term, isInTerm, isInLecturePeriod } }


const SHIFTS = {
  'early':           { name: 'Fr√ºh',          time: '06:45-12:00', type: 'weekday', hours: 5.25 },
  'midday':          { name: 'Mittel',        time: '11:45-17:00', type: 'weekday', hours: 5.25 },
  'evening':         { name: 'Abend',         time: '17:00-20:30', type: 'weekday', hours: 3.5 },
  'closing':         { name: 'Sp√§t',          time: '16:45-22:15', type: 'weekday', hours: 5.5 },
  'weekend-early':   { name: 'WE Fr√ºh',       time: '08:45-14:35', type: 'weekend', hours: 5.83 },
  'weekend-late':    { name: 'WE Sp√§t',       time: '14:25-20:15', type: 'weekend', hours: 5.83 },
  'holiday-early':   { name: 'Feiertag Fr√ºh', time: '08:45-13:15', type: 'holiday', hours: 4.5 },
  'holiday-late':    { name: 'Feiertag Sp√§t', time: '13:05-17:15', type: 'holiday', hours: 4.17 }
};

/* ===================== PERSISTENCE / LOG ===================== */
// Debounced save to prevent excessive localStorage writes
let saveTimeout = null;
const saveData = (immediate = false) => {
  if (immediate) {
    if (saveTimeout) {
      clearTimeout(saveTimeout);
      saveTimeout = null;
    }
    performSave();
  } else {
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(performSave, 300); // Debounce 300ms
  }
};

const performSave = () => {
  try {
    // Batch localStorage operations
    const dataToSave = {
      staffData,
      availabilityData,
      scheduleData,
      holidays,
      auditLog,
      studentTempException,
      otherStaffData,
      carryoverByStaffAndMonth,
      monthHoursCache,
      vacationLedger,
      permanentOvertimeConsent,
      overtimeCredits,
      voluntaryEveningAvailability,
      weekendAssignments,
      studentWeekdayDaytimeShifts,
      studentExceptionWeeks,
      academicTermCache
    };

    Object.entries(dataToSave).forEach(([key, value]) => {
      localStorage.setItem(key, JSON.stringify(value));
    });
  } catch (error) {
    console.error('Failed to save data:', error);
    // Handle quota exceeded or other storage errors
    if (error.name === 'QuotaExceededError') {
      alert('Speicher voll. Bitte l√∂schen Sie alte Daten oder verwenden Sie den Export.');
    }
  }
};
const logAction = (description) => {
  auditLog.unshift({ timestamp: new Date().toISOString(), description });
  if (auditLog.length > 100) auditLog.pop();
  saveData();
  if (document.getElementById('log-tab')?.classList.contains('active')) displayLog();
};
function getCarryoverFor(staffId, monthKey) {
  return carryoverByStaffAndMonth?.[monthKey]?.[staffId] ?? 0;
}
function setCarryoverFor(staffId, monthKey, hours) {
  if (!carryoverByStaffAndMonth[monthKey]) carryoverByStaffAndMonth[monthKey] = {};
  carryoverByStaffAndMonth[monthKey][staffId] = Number.isFinite(+hours) ? +hours : 0;
  localStorage.setItem('carryoverByStaffAndMonth', JSON.stringify(carryoverByStaffAndMonth));
  logAction(`√úbertrag gespeichert: ${hours}h f√ºr ${monthKey} (ID ${staffId}).`);
}


/* ===================== TEMPLATE UTILITIES ===================== */
// Template management utilities for better HTML/JS separation
const TemplateManager = {
  // Get a cloned template with error handling
  getTemplate(templateId) {
    const template = document.getElementById(templateId);
    if (!template) {
      console.error(`Template with id '${templateId}' not found`);
      return null;
    }
    return template.content.cloneNode(true);
  },

  // Populate template with data using data attributes
  populateTemplate(clone, data) {
    Object.entries(data).forEach(([key, value]) => {
      const element = clone.querySelector(`[data-${key}]`);
      if (element) {
        if (typeof value === 'function') {
          value(element);
        } else if (element.tagName === 'INPUT') {
          element.value = value;
        } else {
          element.textContent = value;
        }
      }
    });
    return clone;
  },

  // Create and populate template in one call
  createFromTemplate(templateId, data = {}) {
    const clone = this.getTemplate(templateId);
    if (!clone) return null;
    return this.populateTemplate(clone, data);
  }
};

/* ===================== MEMORY MANAGEMENT UTILITIES ===================== */
// Memory monitoring and cleanup utilities
const MemoryManager = {
  // Monitor memory usage (if available)
  getMemoryInfo() {
    if (performance.memory) {
      return {
        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
      };
    }
    return null;
  },

  // Clean up old data to free memory
  cleanupOldData() {
    const currentYear = new Date().getFullYear();
    const cutoffYear = currentYear - 2;

    // Clean up old holidays
    Object.keys(holidays).forEach(year => {
      if (parseInt(year) < cutoffYear) {
        delete holidays[year];
      }
    });

    // Clean up old schedule data
    Object.keys(scheduleData).forEach(monthKey => {
      const [year] = monthKey.split('-').map(Number);
      if (year < cutoffYear) {
        delete scheduleData[monthKey];
      }
    });

    // Trim audit log if too large
    if (auditLog.length > 200) {
      auditLog.splice(100); // Keep only last 100 entries
    }

    saveData(true); // Immediate save
    console.log('Memory cleanup completed');
  },

  // Force garbage collection if available (Chrome DevTools)
  forceGC() {
    if (window.gc) {
      window.gc();
    }
  }
};

/* ===================== INIT / ROUTING ===================== */
document.addEventListener('DOMContentLoaded', async () => {
  populateMonthSelectors();
  showTab(null, 'staff');
  onScheduleMonthChange();

  // Preload holidays for current and next year
  try {
    await preloadHolidays();
  } catch (e) {
    console.warn('Holiday preloading failed:', e);
  }

  // Clean up old academic term cache entries
  cleanupAcademicTermCache();

  // Periodic memory cleanup (every 30 minutes)
  window.memoryCleanupInterval = setInterval(() => {
    MemoryManager.cleanupOldData();
    cleanupAcademicTermCache(); // Also cleanup term cache periodically
  }, 30 * 60 * 1000);
});

const showTab = (event, tabName) => {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  const section = document.getElementById(`${tabName}-tab`);
  if (section) section.classList.add('active');
  const activeTab = event ? event.currentTarget : document.querySelector(`.tab[onclick*="${tabName}"]`);
  if (activeTab) activeTab.classList.add('active');

  switch (tabName) {
    case 'staff': displayStaffList(); resetStaffForm(); displayOvertimeRequests(); break;
    case 'availability': populateStaffSelector('availabilityStaffSelect'); handleAvailabilityDisplay(); break;
    case 'vacation': displayVacationLedger(); break;
    case 'schedule': displaySchedule(); break;
    case 'reports': generateReport(); break;
    case 'log': displayLog(); break;
    case 'otherstaff': displayOtherStaffList(); resetOtherStaffForm(); break;
  }
};

/* ===================== DATE UTILS ===================== */
const pad2 = (n) => String(n).padStart(2, '0');
const toLocalISOMonth = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}`;
const toLocalISODate  = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

const formatDateDE = (dateStr) => {
  if (!dateStr || typeof dateStr !== 'string' || !dateStr.includes('-')) return dateStr;
  const [y,m,d] = dateStr.split('-');
  return `${d}.${m}.${y}`;
};
const parseShiftTime = (dateStr, timeStr) => {
  const [hours, minutes] = timeStr.split(':');
  const [year, month, day] = dateStr.split('-');
  return new Date(year, month - 1, day, hours, minutes);
};
const getWeekNumber = (d) => {
  d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
};

/* ===================== HOLIDAYS ===================== */
// Cache holidays for current and next year at startup
const preloadHolidays = async () => {
  const currentYear = new Date().getFullYear();
  const nextYear = currentYear + 1;

  for (const year of [currentYear, nextYear]) {
    if (!holidays[year]) {
      await ensureHolidaysForYear(year);
    }
  }
};

const ensureHolidaysForYear = async (year) => {
  if (holidays[year]) return true;

  // Try to use cached data from previous years as fallback
  const fallbackData = getFallbackHolidays(year);

  try {
    const response = await fetch(`https://date.nager.at/api/v3/PublicHolidays/${year}/DE`);
    if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
    const allGermanHolidays = await response.json();
    const filtered = allGermanHolidays.filter(h =>
      !h.counties || (Array.isArray(h.counties) && h.counties.includes(`DE-${APP_CONFIG.HOLIDAY_API_STATE}`))
    );
    holidays[year] = {};
    filtered.forEach(h => { holidays[year][h.date] = h.localName; });
    saveData();
    logAction(`Feiertage f√ºr ${year} erfolgreich geladen und gefiltert.`);
    return true;
  } catch (e) {
    console.error("Could not fetch holidays:", e);

    if (fallbackData && Object.keys(fallbackData).length > 0) {
      holidays[year] = fallbackData;
      logAction(`Verwende Fallback-Feiertage f√ºr ${year}`);
      console.log(`Using fallback holidays for ${year}`);
      saveData();
      return true;
    } else {
      alert(`Fehler beim Laden der Feiertage f√ºr ${year}. Bitte versuchen Sie es sp√§ter erneut.`);
      holidays[year] = {};
      return false;
    }
  }
};

// Generate fallback holidays based on fixed dates
const getFallbackHolidays = (year) => {
  const fixedHolidays = {
    [`${year}-01-01`]: 'Neujahr',
    [`${year}-05-01`]: 'Tag der Arbeit',
    [`${year}-10-03`]: 'Tag der Deutschen Einheit',
    [`${year}-12-25`]: '1. Weihnachtsfeiertag',
    [`${year}-12-26`]: '2. Weihnachtsfeiertag'
  };

  // Try to estimate Easter-based holidays (simplified calculation)
  try {
    const easter = calculateEaster(year);
    if (easter) {
      const goodFriday = new Date(easter);
      goodFriday.setDate(easter.getDate() - 2);
      const easterMonday = new Date(easter);
      easterMonday.setDate(easter.getDate() + 1);
      const ascension = new Date(easter);
      ascension.setDate(easter.getDate() + 39);
      const whitMonday = new Date(easter);
      whitMonday.setDate(easter.getDate() + 50);

      fixedHolidays[toLocalISODate(goodFriday)] = 'Karfreitag';
      fixedHolidays[toLocalISODate(easterMonday)] = 'Ostermontag';
      fixedHolidays[toLocalISODate(ascension)] = 'Christi Himmelfahrt';
      fixedHolidays[toLocalISODate(whitMonday)] = 'Pfingstmontag';
    }
  } catch (e) {
    console.warn('Easter calculation failed for fallback holidays');
  }

  return fixedHolidays;
};

// Simplified Easter calculation (Gregorian calendar)
const calculateEaster = (year) => {
  const a = year % 19;
  const b = Math.floor(year / 100);
  const c = year % 100;
  const d = Math.floor(b / 4);
  const e = b % 4;
  const f = Math.floor((b + 8) / 25);
  const g = Math.floor((b - f + 1) / 3);
  const h = (19 * a + b - d - g + 15) % 30;
  const i = Math.floor(c / 4);
  const k = c % 4;
  const l = (32 + 2 * e + 2 * i - h - k) % 7;
  const m = Math.floor((a + 11 * h + 22 * l) / 451);
  const month = Math.floor((h + l - 7 * m + 114) / 31);
  const day = ((h + l - 7 * m + 114) % 31) + 1;
  return new Date(year, month - 1, day);
};
const showHolidaysPopup = async () => {
  const year = new Date().getFullYear();
  await ensureHolidaysForYear(year);
  const container = document.getElementById('holidaysModalContent');
  const title = document.getElementById('holidaysModalTitle');
  title.innerText = `Gesetzliche Feiertage ${year} in Hessen & Bundesweit`;

  // Clear container
  cleanupContainer(container);

  const yr = holidays[year];
  if (!yr || Object.keys(yr).length === 0) {
    container.innerHTML = '<p>Keine Feiertage f√ºr dieses Jahr geladen. Bitte pr√ºfen Sie die Internetverbindung.</p>';
  } else {
    const template = document.getElementById('holidays-table-template');
    const clone = template.content.cloneNode(true);
    const tbody = clone.querySelector('[data-table-body]');

    Object.keys(yr).sort((a,b)=>new Date(a)-new Date(b)).forEach(d => {
      const row = document.createElement('tr');
      const dateCell = document.createElement('td');
      const holidayCell = document.createElement('td');

      dateCell.textContent = formatDateDE(d);
      holidayCell.textContent = yr[d];

      row.appendChild(dateCell);
      row.appendChild(holidayCell);
      tbody.appendChild(row);
    });

    container.appendChild(clone);
  }
  openModal('holidaysModal');
};

/* ===================== ALTERNATIVE WEEKEND FUNCTIONALITY (PLACEHOLDER) ===================== */
/*
 * ALTERNATIVE WEEKEND SYSTEM - CURRENTLY DORMANT
 *
 * PURPOSE:
 * Ensures fair work-life balance for weekend-preferring permanent employees by providing
 * guaranteed two-day rest periods during the week (their "alternative weekend").
 *
 * FAIRNESS PRINCIPLE:
 * Weekend-preferring employees work Sat/Sun as regular hours, but need protected rest days
 * during the week where scheduling requires overtime consent (just like regular employees
 * need overtime consent for weekend work).
 *
 * ACTIVATION STEPS:
 * 1. Set APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED = true
 * 2. Uncomment all placeholder code sections marked with TODO
 * 3. Uncomment UI form fields in Personnel Management section
 * 4. Test with a weekend-preferring permanent employee
 *
 * IMPLEMENTATION FEATURES (when activated):
 * - alternativeWeekendDays: [2, 3] = Tuesday/Wednesday as protected rest days
 * - Overtime consent required for alternative weekend assignments
 * - Heavy scoring penalties for alternative weekend work
 * - Alternative weekend days excluded from monthly target calculations
 * - Alternative weekend hours count as overtime (with consent)
 *
 * EXAMPLE USAGE:
 * Employee works Sat/Sun as regular hours, but Tue/Wed require overtime consent
 * and count as overtime hours, ensuring fair work-life balance.
 */
// TODO: Activate these functions when alternative weekend functionality is needed

// Check if a date falls on an employee's alternative weekend days
const isAlternativeWeekendDay = (dateStr, staffId) => {
  // PLACEHOLDER: Currently disabled
  if (!APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED) return false;

  /* TODO: Uncomment when needed
  const staff = staffData.find(s => s.id === staffId);
  if (!staff || !staff.alternativeWeekendDays || staff.alternativeWeekendDays.length !== 2) return false;

  const date = new Date(dateStr);
  const dayOfWeek = date.getDay(); // 0=Sunday, 1=Monday, etc.
  return staff.alternativeWeekendDays.includes(dayOfWeek);
  */

  return false;
};

// Validate alternative weekend days are consecutive weekdays
const validateAlternativeWeekendDays = (day1, day2) => {
  // PLACEHOLDER: Currently disabled
  if (!APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED) return true;

  /* TODO: Uncomment when needed
  if (!day1 || !day2) return false;
  const days = [parseInt(day1), parseInt(day2)].sort();

  // Must be weekdays (1-5) and consecutive
  if (days[0] < 1 || days[1] > 5) return false;
  return (days[1] - days[0] === 1) || (days[0] === 1 && days[1] === 5); // Mon-Tue through Thu-Fri, or Fri-Mon
  */

  return true;
};

/* ===================== OVERTIME CONSENT SYSTEM ===================== */

// Check if a shift requires overtime consent for permanent employees
const requiresOvertimeConsent = (shiftKey, dateStr, staffId = null) => {
  const date = new Date(dateStr);
  const isWeekend = [0, 6].includes(date.getDay());
  const isWeekendShift = shiftKey.startsWith('weekend-');

  // Check alternative weekend days first (if enabled)
  if (staffId && APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED && APP_CONFIG.ALTERNATIVE_WEEKEND_REQUIRES_CONSENT) {
    if (isAlternativeWeekendDay(dateStr, staffId)) {
      return true; // Alternative weekend days always require consent
    }
  }

  // Only weekend work potentially counts as overtime - evenings are regular shifts
  if (!isWeekend && !isWeekendShift) return false;

  // If staff ID provided, check weekend preference
  if (staffId) {
    const staff = staffData.find(s => s.id === staffId);
    if (staff && staff.weekendPreference) {
      // Weekend-preferring permanent employees work weekends as regular hours
      return false;
    }
  }

  return true;
};

// Get overtime consent status
const getOvertimeConsentStatus = (staffId, dateStr, shiftKey) => {
  return permanentOvertimeConsent[staffId]?.[dateStr]?.[shiftKey] || null;
};

// Set overtime consent status
const setOvertimeConsentStatus = (staffId, dateStr, shiftKey, status) => {
  if (!permanentOvertimeConsent[staffId]) permanentOvertimeConsent[staffId] = {};
  if (!permanentOvertimeConsent[staffId][dateStr]) permanentOvertimeConsent[staffId][dateStr] = {};
  permanentOvertimeConsent[staffId][dateStr][shiftKey] = status;
  saveData();
};

// Request overtime consent
const requestOvertimeConsent = (staffId, dateStr, shiftKey, reason = '') => {
  setOvertimeConsentStatus(staffId, dateStr, shiftKey, 'requested');
  const staff = staffData.find(s => s.id === staffId);
  logAction(`√úberstunden-Anfrage gestellt: ${staff?.name} f√ºr ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name}) - ${reason}`);
  displayOvertimeRequests();
};

// Handle overtime consent response
const handleOvertimeConsent = (staffId, dateStr, shiftKey, response) => {
  const staff = staffData.find(s => s.id === staffId);
  setOvertimeConsentStatus(staffId, dateStr, shiftKey, response);

  if (response === 'consented') {
    logAction(`√úberstunden-Zustimmung erteilt: ${staff?.name} f√ºr ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
    showToast(`√úberstunden-Zustimmung von ${staff?.name} erhalten`, 'success');
  } else if (response === 'declined') {
    logAction(`√úberstunden-Anfrage abgelehnt: ${staff?.name} f√ºr ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
    showToast(`√úberstunden-Anfrage von ${staff?.name} abgelehnt`, 'info');
  }

  displayOvertimeRequests();
  closeModal('overtimeConsentModal');
};

// Calculate overtime hours for permanent employees
const calculateOvertimeHours = (staffId, monthKey) => {
  const schedule = scheduleData[monthKey];
  if (!schedule) return 0;

  let overtimeHours = 0;
  Object.entries(schedule).forEach(([dateStr, dayData]) => {
    Object.entries(dayData.assignments || {}).forEach(([shiftKey, assignedStaffId]) => {
      if (assignedStaffId === staffId && requiresOvertimeConsent(shiftKey, dateStr, staffId)) {
        const consentStatus = getOvertimeConsentStatus(staffId, dateStr, shiftKey);
        if (consentStatus === 'consented') {
          overtimeHours += SHIFTS[shiftKey].hours;
        }
      }
    });
  });

  return overtimeHours;
};

// Get overtime credits for a staff member in a month
const getOvertimeCredits = (staffId, monthKey) => {
  return overtimeCredits[monthKey]?.[staffId] || 0;
};

// Set overtime credits
const setOvertimeCredits = (staffId, monthKey, hours) => {
  if (!overtimeCredits[monthKey]) overtimeCredits[monthKey] = {};
  overtimeCredits[monthKey][staffId] = hours;
  saveData();
};

// Update overtime credits based on worked overtime
const updateOvertimeCredits = (monthKey) => {
  staffData.filter(s => s.type === 'permanent').forEach(staff => {
    const overtimeHours = calculateOvertimeHours(staff.id, monthKey);
    setOvertimeCredits(staff.id, monthKey, overtimeHours);
  });
};

/* ===================== VOLUNTARY EVENING AVAILABILITY ===================== */
// Get voluntary evening availability status
const getVoluntaryEveningAvailability = (staffId, dateStr, shiftKey) => {
  return voluntaryEveningAvailability[staffId]?.[dateStr]?.[shiftKey] || false;
};

// Set voluntary evening availability
const setVoluntaryEveningAvailability = (staffId, dateStr, shiftKey, isVoluntary) => {
  if (!voluntaryEveningAvailability[staffId]) voluntaryEveningAvailability[staffId] = {};
  if (!voluntaryEveningAvailability[staffId][dateStr]) voluntaryEveningAvailability[staffId][dateStr] = {};
  voluntaryEveningAvailability[staffId][dateStr][shiftKey] = isVoluntary;
  saveData();
};

// Check if permanent employee prefers evening shifts
const prefersEveningShifts = (staff) => {
  return staff.preference === 'evening';
};

// Check if permanent employee has reduced evening penalty for a shift
const hasReducedEveningPenalty = (staffId, dateStr, shiftKey) => {
  const staff = staffData.find(s => s.id === staffId);
  if (!staff || staff.type !== 'permanent') return false;

  const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
  if (!isEveningShift) return false;

  // Check if they prefer evenings generally
  if (prefersEveningShifts(staff)) return true;

  // Check if they volunteered for this specific date/shift
  return getVoluntaryEveningAvailability(staffId, dateStr, shiftKey);
};

/* ===================== STAFF MGMT ===================== */
const togglePreferenceField = () => {
  const type = document.getElementById('staffType').value;
  document.getElementById('preference-group').style.display = (type === 'permanent') ? 'block' : 'none';
};

const addVacationPeriod = () => {
  const start = document.getElementById('vacationStart').value;
  const end = document.getElementById('vacationEnd').value;
  if (!start || !end || end < start) return alert("Bitte g√ºltiges Start- und Enddatum f√ºr den Urlaub eingeben.");
  tempVacationPeriods.push({ start, end });
  renderVacationList();
  document.getElementById('vacationStart').value = '';
  document.getElementById('vacationEnd').value = '';
};

const renderVacationList = () => {
  const list = document.getElementById('vacationList');
  const template = document.getElementById('vacation-li-template');

  // Clear existing content and remove event listeners
  while (list.firstChild) {
    list.removeChild(list.firstChild);
  }

  tempVacationPeriods.forEach((p, index) => {
    const liClone = template.content.cloneNode(true);
    liClone.querySelector('[data-dates]').textContent = `${formatDateDE(p.start)} bis ${formatDateDE(p.end)}`;
    const button = liClone.querySelector('button');
    button.addEventListener('click', () => removeTempVacation(index));
    // Store reference for cleanup
    button._vacationIndex = index;
    list.appendChild(liClone);
  });
};

const removeTempVacation = (index) => {
  tempVacationPeriods.splice(index, 1);
  renderVacationList();
};

const addIllnessPeriod = () => {
  const start = document.getElementById('illnessStart').value;
  const end = document.getElementById('illnessEnd').value;
  if (!start || !end || end < start) return alert("Bitte g√ºltiges Start- und Enddatum f√ºr die Krankmeldung eingeben.");
  tempIllnessPeriods.push({ start, end });
  renderIllnessList();
  document.getElementById('illnessStart').value = '';
  document.getElementById('illnessEnd').value = '';
};

const renderIllnessList = () => {
  const list = document.getElementById('illnessList');
  const template = document.getElementById('vacation-li-template');

  // Clear existing content and remove event listeners
  while (list.firstChild) {
    list.removeChild(list.firstChild);
  }

  tempIllnessPeriods.forEach((p, index) => {
    const liClone = template.content.cloneNode(true);
    liClone.querySelector('[data-dates]').textContent = `${formatDateDE(p.start)} bis ${formatDateDE(p.end)}`;
    const button = liClone.querySelector('button');
    button.addEventListener('click', () => removeTempIllness(index));
    // Store reference for cleanup
    button._illnessIndex = index;
    list.appendChild(liClone);
  });
};

const removeTempIllness = (index) => {
  tempIllnessPeriods.splice(index, 1);
  renderIllnessList();
};

const addStaff = () => {
  const name = document.getElementById('staffName').value.trim();
  if (!name) return alert("Name ist erforderlich.");
  const newStaff = {
    id: Date.now(),
    name,
    type: document.getElementById('staffType').value,
    contractHours: parseFloat(document.getElementById('contractHours').value) || 0,
    typicalWorkdays: parseInt(document.getElementById('typicalWorkdays').value) || 0,
    preference: document.getElementById('staffPreference').value,
    weekendPreference: document.getElementById('weekendPreference').checked,
    vacations: [...tempVacationPeriods],
    illnessPeriods: [...tempIllnessPeriods]

    // PLACEHOLDER: Alternative weekend days (currently disabled)
    // TODO: Uncomment when alternative weekend functionality is needed
    /*
    , alternativeWeekendDays: (() => {
      if (!APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED) return null;
      const day1 = document.getElementById('alternativeWeekendDay1').value;
      const day2 = document.getElementById('alternativeWeekendDay2').value;
      if (day1 && day2 && validateAlternativeWeekendDays(day1, day2)) {
        return [parseInt(day1), parseInt(day2)].sort();
      }
      return null;
    })()
    */
  };
  staffData.push(newStaff);
  logAction(`Mitarbeiter hinzugef√ºgt: ${name}`);
  saveData();
  resetStaffForm();
  displayStaffList();
};

const editStaff = (id) => {
  const staff = staffData.find(s => s.id === id);
  if (!staff) return;
  document.getElementById('staffIdToEdit').value = id;
  document.getElementById('staffFormTitle').innerText = `${staff.name} bearbeiten`;
  document.getElementById('staffName').value = staff.name;
  document.getElementById('staffType').value = staff.type;
  document.getElementById('contractHours').value = staff.contractHours;
  document.getElementById('typicalWorkdays').value = staff.typicalWorkdays || '';
  document.getElementById('staffPreference').value = staff.preference || 'none';
  document.getElementById('weekendPreference').checked = staff.weekendPreference || false;
  togglePreferenceField();

  // PLACEHOLDER: Load alternative weekend days (currently disabled)
  // TODO: Uncomment when alternative weekend functionality is needed
  /*
  if (APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED && staff.alternativeWeekendDays) {
    document.getElementById('alternativeWeekendDay1').value = staff.alternativeWeekendDays[0] || '';
    document.getElementById('alternativeWeekendDay2').value = staff.alternativeWeekendDays[1] || '';
  }
  */
  tempVacationPeriods = [...(staff.vacations || [])];
  tempIllnessPeriods = [...(staff.illnessPeriods || [])];
  renderVacationList();
  renderIllnessList();
  const saveBtn = document.getElementById('saveStaffBtn');
  saveBtn.innerText = "√Ñnderungen speichern";
  saveBtn.onclick = saveStaffChanges;
  document.getElementById('cancelEditBtn').style.display = 'block';
  window.scrollTo(0, 0);
};

const saveStaffChanges = () => {
  const id = parseInt(document.getElementById('staffIdToEdit').value);
  const i = staffData.findIndex(s => s.id === id);
  if (i === -1) return;

  staffData[i] = {
    ...staffData[i],
    name: document.getElementById('staffName').value.trim(),
    type: document.getElementById('staffType').value,
    contractHours: parseFloat(document.getElementById('contractHours').value) || 0,
    typicalWorkdays: parseInt(document.getElementById('typicalWorkdays').value) || 0,
    preference: document.getElementById('staffPreference').value,
    weekendPreference: document.getElementById('weekendPreference').checked,
    vacations: [...tempVacationPeriods],
    illnessPeriods: [...tempIllnessPeriods]
  };
  logAction(`Mitarbeiter aktualisiert: ${staffData[i].name}`);
  saveData();
  resetStaffForm();
  displayStaffList();
};

const resetStaffForm = () => {
  document.getElementById('staffFormTitle').innerText = "Neue Arbeitskraft hinzuf√ºgen";
  document.getElementById('staffIdToEdit').value = '';
  document.getElementById('staffName').value = '';
  document.getElementById('contractHours').value = '';
  document.getElementById('typicalWorkdays').value = '';
  document.getElementById('vacationStart').value = '';
  document.getElementById('vacationEnd').value = '';
  document.getElementById('illnessStart').value = '';
  document.getElementById('illnessEnd').value = '';
  document.getElementById('staffPreference').value = 'none';
  document.getElementById('weekendPreference').checked = false;
  document.getElementById('staffType').value = 'minijob';

  // PLACEHOLDER: Reset alternative weekend days (currently disabled)
  // TODO: Uncomment when alternative weekend functionality is needed
  /*
  if (APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED) {
    document.getElementById('alternativeWeekendDay1').value = '';
    document.getElementById('alternativeWeekendDay2').value = '';
  }
  */
  tempVacationPeriods = [];
  tempIllnessPeriods = [];
  renderVacationList();
  renderIllnessList();
  const saveBtn = document.getElementById('saveStaffBtn');
  saveBtn.innerText = "Arbeitskraft speichern";
  saveBtn.onclick = addStaff;
  document.getElementById('cancelEditBtn').style.display = 'none';
  togglePreferenceField();
};

// Helper function to clean up DOM elements and their event listeners
const cleanupContainer = (container) => {
  while (container.firstChild) {
    const child = container.firstChild;
    // Remove any stored event listeners
    if (child.nodeType === Node.ELEMENT_NODE) {
      const buttons = child.querySelectorAll('button');
      buttons.forEach(btn => {
        // Clone and replace to remove all event listeners
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);
      });
    }
    container.removeChild(child);
  }
};

// Display overtime requests
const displayOvertimeRequests = () => {
  const container = document.getElementById('overtimeRequestsList');
  cleanupContainer(container);

  const requests = [];

  // Collect all pending requests
  Object.entries(permanentOvertimeConsent).forEach(([staffId, staffRequests]) => {
    const staff = staffData.find(s => s.id == staffId);
    if (!staff || staff.type !== 'permanent') return;

    Object.entries(staffRequests).forEach(([dateStr, dateRequests]) => {
      Object.entries(dateRequests).forEach(([shiftKey, status]) => {
        if (status === 'requested') {
          requests.push({
            staffId: parseInt(staffId),
            staffName: staff.name,
            dateStr,
            shiftKey,
            status
          });
        }
      });
    });
  });

  if (requests.length === 0) {
    container.innerHTML = '<p style="color: #6c757d; font-style: italic;">Keine ausstehenden √úberstunden-Anfragen</p>';
    return;
  }

  // Sort by date
  requests.sort((a, b) => new Date(a.dateStr) - new Date(b.dateStr));

  requests.forEach(request => {
    const template = document.getElementById('overtime-request-item');
    const clone = template.content.cloneNode(true);

    clone.querySelector('[data-date]').textContent = formatDateDE(request.dateStr);
    clone.querySelector('[data-shift-info]').textContent = `${SHIFTS[request.shiftKey].name} (${SHIFTS[request.shiftKey].time})`;
    clone.querySelector('[data-status]').textContent = 'Ausstehend';

    const consentBtn = clone.querySelector('[data-consent-btn]');
    const declineBtn = clone.querySelector('[data-decline-btn]');

    consentBtn.addEventListener('click', () => {
      handleOvertimeConsent(request.staffId, request.dateStr, request.shiftKey, 'consented');
    });

    declineBtn.addEventListener('click', () => {
      handleOvertimeConsent(request.staffId, request.dateStr, request.shiftKey, 'declined');
    });

    container.appendChild(clone);
  });
};

const displayStaffList = () => {
  const container = document.getElementById('staffList');
  const template = document.getElementById('staff-card-template');

  // Properly clean up existing content
  cleanupContainer(container);

  staffData.forEach(staff => {
    const cardClone = template.content.cloneNode(true);

    cardClone.querySelector('[data-name]').textContent = staff.name;
    cardClone.querySelector('[data-type]').textContent = staff.type;
    cardClone.querySelector('[data-contract-hours]').textContent = staff.contractHours;
    cardClone.querySelector('[data-workdays]').textContent = staff.typicalWorkdays || 'N/A';

    if (staff.type === 'permanent' && staff.preference && staff.preference !== 'none') {
      const prefMap = {
        early: 'Fr√ºh bevorzugt',
        midday: 'Mittel bevorzugt',
        evening: 'Abend bevorzugt'
      };
      cardClone.querySelector('[data-preference]').textContent = prefMap[staff.preference];
      cardClone.querySelector('[data-preference-container]').style.display = 'block';
    }

    // Show weekend preference for all staff types
    if (staff.weekendPreference) {
      const weekendPrefElement = document.createElement('div');
      weekendPrefElement.style.cssText = 'margin-top: 5px; padding: 3px 8px; background: #e8f5e8; border-radius: 3px; font-size: 0.9em;';
      weekendPrefElement.innerHTML = '‚≠ê Wochenend-Pr√§ferenz';
      cardClone.querySelector('.card-body').appendChild(weekendPrefElement);
    }

    // PLACEHOLDER: Show alternative weekend days (currently disabled)
    // TODO: Uncomment when alternative weekend functionality is needed
    /*
    if (APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED && staff.alternativeWeekendDays && staff.alternativeWeekendDays.length === 2) {
      const dayNames = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
      const altWeekendElement = document.createElement('div');
      altWeekendElement.style.cssText = 'margin-top: 5px; padding: 3px 8px; background: #fff3cd; border-radius: 3px; font-size: 0.9em;';
      altWeekendElement.innerHTML = `üè† Alternative Ruhetage: ${staff.alternativeWeekendDays.map(d => dayNames[d]).join(', ')}`;
      cardClone.querySelector('.card-body').appendChild(altWeekendElement);
    }
    */

    const vacationList = cardClone.querySelector('[data-vacation-list]');
    if (staff.vacations && staff.vacations.length > 0) {
      staff.vacations.forEach(v => {
        const li = document.createElement('li');
        li.textContent = `${formatDateDE(v.start)} bis ${formatDateDE(v.end)}`;
        vacationList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'Keine';
      vacationList.appendChild(li);
    }

    const illnessHeader = document.createElement('h5');
    illnessHeader.textContent = 'Krankmeldungen:';
    cardClone.querySelector('.form-row').before(illnessHeader);
    const illnessList = document.createElement('ul');
    if (staff.illnessPeriods && staff.illnessPeriods.length > 0) {
        staff.illnessPeriods.forEach(p => {
            const li = document.createElement('li');
            li.textContent = `${formatDateDE(p.start)} bis ${formatDateDE(p.end)}`;
            illnessList.appendChild(li);
        });
    } else {
        const li = document.createElement('li');
        li.textContent = 'Keine';
        illnessList.appendChild(li);
    }
    illnessHeader.after(illnessList);

    cardClone.querySelector('[data-edit-btn]').addEventListener('click', () => editStaff(staff.id));
    cardClone.querySelector('[data-delete-btn]').addEventListener('click', () => removeStaff(staff.id));

    container.appendChild(cardClone);
  });
};
/* ===================== OTHER STAFF (non-reception) ===================== */
const addOtherVacationPeriod = () => {
  const start = document.getElementById('otherVacationStart').value;
  const end = document.getElementById('otherVacationEnd').value;
  if (!start || !end || end < start) return alert("Bitte g√ºltiges Start- und Enddatum f√ºr den Urlaub eingeben.");
  tempOtherVacations.push({ start, end });
  renderOtherVacationList();
  document.getElementById('otherVacationStart').value = '';
  document.getElementById('otherVacationEnd').value = '';
};
const removeOtherVacation = (i) => { tempOtherVacations.splice(i, 1); renderOtherVacationList(); };

const resetOtherStaffForm = () => {
  document.getElementById('otherStaffFormTitle').innerText = "Mitarbeitende hinzuf√ºgen";
  document.getElementById('otherStaffIdToEdit').value = '';
  document.getElementById('otherStaffName').value = '';
  tempOtherVacations = [];
  renderOtherVacationList();
  const btn = document.getElementById('saveOtherStaffBtn');
  btn.innerText = "Speichern";
  btn.onclick = addOtherStaff;
  document.getElementById('cancelOtherEditBtn').style.display = 'none';
};

const addOtherStaff = () => {
  const name = document.getElementById('otherStaffName').value.trim();
  if (!name) return alert("Name ist erforderlich.");
  otherStaffData.push({ id: Date.now(), name, vacations: [...tempOtherVacations] });
  logAction(`Weitere/r Mitarbeiter/in hinzugef√ºgt: ${name}`);
  saveData();
  resetOtherStaffForm();
  displayOtherStaffList();
};

const editOtherStaff = (id) => {
  const s = otherStaffData.find(x => x.id === id);
  if (!s) return;
  document.getElementById('otherStaffIdToEdit').value = id;
  document.getElementById('otherStaffFormTitle').innerText = `${s.name} bearbeiten`;
  document.getElementById('otherStaffName').value = s.name;
  tempOtherVacations = [...(s.vacations || [])];
  renderOtherVacationList();
  const btn = document.getElementById('saveOtherStaffBtn');
  btn.innerText = "√Ñnderungen speichern";
  btn.onclick = saveOtherStaffChanges;
  document.getElementById('cancelOtherEditBtn').style.display = 'block';
  window.scrollTo(0, 0);
};

const saveOtherStaffChanges = () => {
  const id = parseInt(document.getElementById('otherStaffIdToEdit').value);
  const i = otherStaffData.findIndex(x => x.id === id);
  if (i === -1) return;
  const name = document.getElementById('otherStaffName').value.trim();
  otherStaffData[i] = { ...otherStaffData[i], name, vacations: [...tempOtherVacations] };
  logAction(`Weitere/r Mitarbeiter/in aktualisiert: ${name}`);
  saveData();
  resetOtherStaffForm();
  displayOtherStaffList();
};

const removeOtherStaff = (id) => {
  const name = otherStaffData.find(x => x.id === id)?.name;
  if (confirm(`Mitarbeitende/n ${name} wirklich entfernen?`)) {
    otherStaffData = otherStaffData.filter(x => x.id !== id);
    logAction(`Weitere/r Mitarbeiter/in entfernt: ${name}`);
    saveData();
    displayOtherStaffList();
  }
};




/* ===================== AVAILABILITY ===================== */
const populateStaffSelector = (selectId) => {
  const select = document.getElementById(selectId);
  select.innerHTML = '<option value="">-- Bitte ausw√§hlen --</option>';
  staffData.forEach(staff => {
    select.innerHTML += `<option value="${staff.id}">${staff.name} (${staff.type})</option>`;
  });
};

function renderCarryoverBox(staff, monthKey) {
  const cur = getCarryoverFor(staff.id, monthKey);
  const auto = getAutoCarryoverSuggestion(staff, monthKey);
  const inputId = `carryoverInput-${staff.id}-${monthKey}`;

  const clone = TemplateManager.createFromTemplate('carryover-box-template', {
    month: monthKey,
    'auto-value': auto.toFixed(2)
  });

  if (!clone) return document.createElement('div');

  // Show overtime info for permanent employees
  if (staff.type === 'permanent') {
    const overtimeHours = getOvertimeCredits(staff.id, monthKey);
    if (overtimeHours > 0) {
      const overtimeInfo = clone.querySelector('[data-overtime-info]');
      overtimeInfo.style.display = 'block';
      clone.querySelector('[data-overtime-hours]').textContent = overtimeHours.toFixed(2);
    }
  }

  const input = clone.querySelector('[data-carryover-input]');
  input.id = inputId;
  input.value = cur;

  const autoBtn = clone.querySelector('[data-auto-btn]');
  autoBtn.addEventListener('click', () => applyAutoCarryover(staff.id, monthKey, inputId));

  const saveBtn = clone.querySelector('[data-save-btn]');
  saveBtn.addEventListener('click', () => saveCarryoverFromInput(staff.id, monthKey, inputId));

  return clone;
}


function saveCarryoverFromInput(staffId, monthKey, inputId) {
  const v = Number(document.getElementById(inputId).value || 0);
  setCarryoverFor(staffId, monthKey, v);
  showToast ? showToast('√úbertrag gespeichert.', 'success') : alert('√úbertrag gespeichert.');

  if (scheduleData[monthKey]) {
    scheduleData[monthKey] = validateSchedule(scheduleData[monthKey], monthKey);
    saveData();
    if (document.getElementById('schedule-tab')?.classList.contains('active')) {
      displaySchedule();
    }
  }

  if (document.getElementById('availability-tab')?.classList.contains('active')) {
    handleAvailabilityDisplay();
  }
}



const updatePermanentAvailability = (staffId, date, shiftKey, isRequestingOff) => {
  if (!availabilityData[staffId]) availabilityData[staffId] = {};
  if (!availabilityData[staffId][date]) availabilityData[staffId][date] = {};
  if (isRequestingOff) availabilityData[staffId][date][shiftKey] = 'no';
  else delete availabilityData[staffId][date][shiftKey];
  saveData();
};

const updateVoluntaryEveningAvailability = (staffId, dateStr, shiftKey, isVoluntary) => {
  setVoluntaryEveningAvailability(staffId, dateStr, shiftKey, isVoluntary);
  const staff = staffData.find(s => s.id === staffId);
  if (staff) {
    const action = isVoluntary ? 'aktiviert' : 'deaktiviert';
    logAction(`Freiwillige Abendschicht ${action}: ${staff.name} am ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
  }
};
const updateAvailability = (staffId, date, shiftKey, value) => {
  if (!availabilityData[staffId]) availabilityData[staffId] = {};
  if (!availabilityData[staffId][date]) availabilityData[staffId][date] = {};
  availabilityData[staffId][date][shiftKey] = value;
  saveData();
};
const handleAvailabilityDisplay = async () => {
  const staffId = document.getElementById('availabilityStaffSelect').value;
  const month = document.getElementById('availabilityMonth').value;

  if (!staffId) {
    document.getElementById('availabilityForm').innerHTML = '<p>Bitte einen Mitarbeiter ausw√§hlen.</p>';
    return;
  }

  try {
    const [y] = month.split('-').map(Number);
    await ensureHolidaysForYear(y);
  } catch (_) {}

  // This is the single, correct call to the new combined function.
  generateAvailabilityForm();
};

// Helper function to create availability rows with proper column alignment
const createAvailabilityRow = (date, dateStr, staff, year, isHoliday, isWeekend, isPermanent) => {
  const row = document.createElement('tr');
  const rowClass = isHoliday ? 'avail-row is-holiday' : (isWeekend ? 'avail-row is-weekend' : 'avail-row');
  row.className = rowClass;

  // Date cell - include day name and flags in the date column
  const dateCell = document.createElement('td');
  const dayName = date.toLocaleDateString('de-DE', { weekday: 'short' });
  const flag = isHoliday ? `<span class="day-flag">Feiertag</span>` : (isWeekend && !isPermanent ? `<span class="day-flag">Wochenende</span>` : '');
  dateCell.innerHTML = `${formatDateDE(dateStr)} (${dayName}) ${flag}`;
  row.appendChild(dateCell);

  if (isPermanent) {
    // For permanent employees: all weekday shifts (early, midday, evening, closing)
    if (isHoliday) {
      const cell = document.createElement('td');
      cell.colSpan = 4;
      cell.innerHTML = '<div class="na-cell">‚Äî</div>';
      row.appendChild(cell);
    } else {
      ['early', 'midday', 'evening', 'closing'].forEach(shiftKey => {
        const cell = document.createElement('td');
        const isRequestedOff = availabilityData[staff.id]?.[dateStr]?.[shiftKey] === 'no';
        const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
        const isVoluntary = getVoluntaryEveningAvailability(staff.id, dateStr, shiftKey);

        // Main availability checkbox
        const mainLabel = document.createElement('label');
        mainLabel.style.display = 'flex';
        mainLabel.style.alignItems = 'center';
        mainLabel.style.gap = '8px';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = isRequestedOff;
        checkbox.addEventListener('change', () => updatePermanentAvailability(staff.id, dateStr, shiftKey, checkbox.checked));

        mainLabel.appendChild(checkbox);
        mainLabel.appendChild(document.createTextNode('frei'));
        cell.appendChild(mainLabel);

        // Add voluntary evening checkbox for evening shifts
        if (isEveningShift) {
          const voluntaryLabel = document.createElement('label');
          voluntaryLabel.style.display = 'flex';
          voluntaryLabel.style.alignItems = 'center';
          voluntaryLabel.style.gap = '4px';
          voluntaryLabel.style.marginTop = '4px';
          voluntaryLabel.style.fontSize = '0.85em';
          voluntaryLabel.style.color = '#28a745';

          const voluntaryCheckbox = document.createElement('input');
          voluntaryCheckbox.type = 'checkbox';
          voluntaryCheckbox.checked = isVoluntary;
          voluntaryCheckbox.addEventListener('change', () => {
            updateVoluntaryEveningAvailability(staff.id, dateStr, shiftKey, voluntaryCheckbox.checked);
          });

          voluntaryLabel.appendChild(voluntaryCheckbox);
          voluntaryLabel.appendChild(document.createTextNode('freiwillig'));
          cell.appendChild(voluntaryLabel);
        }

        row.appendChild(cell);
      });
    }
  } else {
    // For non-permanent employees: all shifts based on day type
    Object.keys(SHIFTS).forEach(shiftKey => {
      const cell = document.createElement('td');
      const t = SHIFTS[shiftKey].type;
      const allowed = (isHoliday && t === 'holiday') || (!isHoliday && isWeekend && t === 'weekend') || (!isHoliday && !isWeekend && t === 'weekday');

      if (!allowed) {
        cell.innerHTML = '<div class="na-cell">‚Äî</div>';
      } else {
        const cur = availabilityData[staff.id]?.[dateStr]?.[shiftKey] || "";
        const select = document.createElement('select');

        const options = [
          { value: "", text: "‚Äî", selected: cur === "" },
          { value: "no", text: "Nein", selected: cur === "no" },
          { value: "yes", text: "Ja", selected: cur === "yes" },
          { value: "prefer", text: "Bevorzugt", selected: cur === "prefer" }
        ];

        options.forEach(opt => {
          const option = document.createElement('option');
          option.value = opt.value;
          option.textContent = opt.text;
          option.selected = opt.selected;
          select.appendChild(option);
        });

        select.addEventListener('change', () => updateAvailability(staff.id, dateStr, shiftKey, select.value));
        cell.appendChild(select);
      }
      row.appendChild(cell);
    });
  }

  return row;
};

// RENDER the availability table for the selected staff + month
const generateAvailabilityForm = () => {
  const staffId = document.getElementById('availabilityStaffSelect').value;
  const monthKey = document.getElementById('availabilityMonth').value;
  const container = document.getElementById('availabilityForm');

  if (!staffId || !monthKey) {
    container.innerHTML = '<p>Bitte Mitarbeiter und Monat ausw√§hlen.</p>';
    return;
  }

  const staff = staffData.find(s => s.id == staffId);
  const [year, monthNum] = monthKey.split('-').map(Number);

  // Clear container
  cleanupContainer(container);

  // Create main content using templates
  const isPermanent = staff.type === 'permanent';

  if (isPermanent) {
    // Use permanent template for fixed structure
    const template = document.getElementById('availability-permanent-template');
    const clone = template.content.cloneNode(true);
    clone.querySelector('[data-staff-name]').textContent = staff.name;

    const tbody = clone.querySelector('[data-table-body]');
    const daysInMonth = new Date(year, monthNum, 0).getDate();

    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, monthNum - 1, day);
      const dateStr = toLocalISODate(date);
      const isWeekend = [0, 6].includes(date.getDay());
      const isHoliday = !!holidays[year]?.[dateStr];

      // Skip weekends for permanent employees
      if (isWeekend) continue;

      const row = createAvailabilityRow(date, dateStr, staff, year, isHoliday, isWeekend, isPermanent);
      tbody.appendChild(row);
    }

    container.appendChild(clone);
  } else {
    // Create general availability table manually for proper column alignment
    const staffCard = document.createElement('div');
    staffCard.className = 'staff-card';

    const title = document.createElement('h4');
    title.textContent = `Verf√ºgbarkeit f√ºr: ${staff.name}`;
    staffCard.appendChild(title);

    const table = document.createElement('table');
    table.className = 'schedule-table';

    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');

    const dateHeader = document.createElement('th');
    dateHeader.textContent = 'Datum';
    headerRow.appendChild(dateHeader);

    // Add shift headers in correct order
    Object.values(SHIFTS).forEach(shift => {
      const th = document.createElement('th');
      th.textContent = shift.name;
      headerRow.appendChild(th);
    });

    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Create body
    const tbody = document.createElement('tbody');
    const daysInMonth = new Date(year, monthNum, 0).getDate();

    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, monthNum - 1, day);
      const dateStr = toLocalISODate(date);
      const isWeekend = [0, 6].includes(date.getDay());
      const isHoliday = !!holidays[year]?.[dateStr];

      const row = createAvailabilityRow(date, dateStr, staff, year, isHoliday, isWeekend, isPermanent);
      tbody.appendChild(row);
    }

    table.appendChild(tbody);
    staffCard.appendChild(table);
    container.appendChild(staffCard);
  }

  // Add carryover box
  const carryoverBox = renderCarryoverBox(staff, monthKey);
  container.appendChild(carryoverBox);
};

/* ===================== MONTHLY TARGETS (permanent + generic) ===================== */
const computePermanentMonthlyTarget = (staff, year, monthNum) => {
  if (staff.type !== 'permanent' || !staff.contractHours) return 0;

  // Calculate available working days in month
  const availableWorkingDays = (() => {
    let weekdays = 0;
    let weekends = 0;
    const daysInMonth = new Date(year, monthNum, 0).getDate();

    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(year, monthNum - 1, day);
      const dateStr = toLocalISODate(date);
      const isWeekday = ![0, 6].includes(date.getDay());
      const isHoliday = !!holidays[year]?.[dateStr];

      if (!isHoliday) {
        // PLACEHOLDER: Check alternative weekend days (currently disabled)
        const isAlternativeWeekend = APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED && isAlternativeWeekendDay(dateStr, staff.id);

        if (isWeekday && !isAlternativeWeekend) {
          weekdays++;
        } else if (staff.weekendPreference && !isAlternativeWeekend) {
          // Only count weekends for weekend-preferring employees, excluding their alternative weekend
          weekends++;
        }

        // TODO: Alternative weekend days are excluded from available working days
        // This ensures weekend-preferring employees have guaranteed rest days
      }
    }

    return { weekdays, weekends, total: weekdays + weekends };
  })();

  // Calculate daily target based on typical workdays
  const typicalWorkdays = staff.typicalWorkdays || 5;
  const dailyTarget = (staff.contractHours || 0) / typicalWorkdays;

  // For weekend-preferring employees, distribute hours across all available days
  // For non-weekend-preferring employees, only use weekdays
  const targetDays = staff.weekendPreference ? availableWorkingDays.total : availableWorkingDays.weekdays;
  let target = targetDays * dailyTarget;

  // Combine vacations and illness periods
  const excusedPeriods = [...(staff.vacations || []), ...(staff.illnessPeriods || [])];

  excusedPeriods.forEach(period => {
    const start = new Date(period.start);
    const end   = new Date(period.end);
    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      if (d.getFullYear() === year && (d.getMonth() + 1) === monthNum) {
        const isWeekday = ![0, 6].includes(d.getDay());
        const dateStr = toLocalISODate(d);
        const isHoliday = !!holidays[year]?.[dateStr];

        // Deduct for weekdays, and weekends if employee prefers weekends
        // PLACEHOLDER: Exclude alternative weekend days from deduction (currently disabled)
        const isAlternativeWeekend = APP_CONFIG.ALTERNATIVE_WEEKEND_ENABLED && isAlternativeWeekendDay(dateStr, staff.id);

        if (!isHoliday && !isAlternativeWeekend && (isWeekday || staff.weekendPreference)) {
          target -= dailyTarget;
        }

        // TODO: Alternative weekend days are not deducted since they're not counted as working days
      }
    }
  });

  return Math.max(0, +target.toFixed(2));
};

const getWeeksInMonth = (year, monthNum) => {
  let mondays = 0;
  const days = new Date(year, monthNum, 0).getDate();
  for (let d = 1; d <= days; d++) {
    const dt = new Date(year, monthNum - 1, d);
    if (dt.getDay() === 1) mondays++;
  }
  return Math.max(4, mondays);
};

const computeMonthlyTargetGeneric = (staff, year, monthNum) => {
  let baseTarget;
  if (staff.type === 'permanent') {
    // Permanent employee logic is separate and already handles vacations. We'll add illness to it.
    baseTarget = computePermanentMonthlyTarget(staff, year, monthNum);
  } else {
    const weeks = getWeeksInMonth(year, monthNum);
    if (staff.type === 'student' && staff.contractHours > 0) {
      baseTarget = +(weeks * staff.contractHours).toFixed(2);
    } else if (staff.type === 'minijob') {
      // Use legal monthly limit instead of weekly target √ó weeks
      const maxLegalHours = APP_CONFIG.MINIJOB_MAX_EARNING / APP_CONFIG.MINIJOB_HOURLY_WAGE;
      const weeklyTarget = weeks * APP_CONFIG.MINIJOB_TARGET_WEEK_HOURS;
      baseTarget = +Math.min(maxLegalHours, weeklyTarget).toFixed(2);
    } else {
      baseTarget = 0;
    }

    const avgHoursPerDay = (staff.typicalWorkdays > 0) ? (staff.contractHours / staff.typicalWorkdays) : 0;
    if (avgHoursPerDay > 0) {
      let excusedWorkdays = 0;
      // Combine vacations and illness periods for deduction
      const excusedPeriods = [...(staff.vacations || []), ...(staff.illnessPeriods || [])];

      excusedPeriods.forEach(period => {
        const start = new Date(period.start);
        const end = new Date(period.end);
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
          if (d.getFullYear() === year && (d.getMonth() + 1) === monthNum && ![0, 6].includes(d.getDay())) {
            excusedWorkdays++;
          }
        }
      });
      baseTarget -= (excusedWorkdays * avgHoursPerDay);
    }
  }
  return Math.max(0, baseTarget);
};

const computeMonthlyTargetWithCarryover = (staff, year, monthNum) => {
  const base = computeMonthlyTargetGeneric(staff, year, monthNum);
  const monthKey = `${year}-${String(monthNum).padStart(2,'0')}`;
  const co = getCarryoverFor(staff.id, monthKey); // +overshoot / ‚Äìdeficit

  // For permanent employees, subtract overtime credits from target
  let overtimeCredit = 0;
  if (staff.type === 'permanent') {
    overtimeCredit = getOvertimeCredits(staff.id, monthKey);
  }

  return Math.max(0, +(base + co - overtimeCredit).toFixed(2));
};
// --- Auto-suggest carryover helpers ---
function getPrevMonthKey(monthKey) {
  const [y, m] = monthKey.split('-').map(Number);
  const prev = new Date(y, m - 2, 1); // month is 0-based
  return toLocalISOMonth(prev);
}

function getAutoCarryoverSuggestion(staff, monthKey) {
  const prevKey = getPrevMonthKey(monthKey);
  if (!scheduleData[prevKey]) return 0; // no plan last month

  const [py, pm] = prevKey.split('-').map(Number);
  const prevTarget = computeMonthlyTargetWithCarryover(staff, py, pm);
  const prevActual = getActualScheduledHours(staff.id, prevKey);

  const suggestion = +(prevTarget - prevActual).toFixed(2);
  return Math.abs(suggestion) < 0.05 ? 0 : suggestion;
}

function applyAutoCarryover(staffId, monthKey, inputId) {
  const staff = staffData.find(s => s.id === staffId);
  if (!staff) return;
  const auto = getAutoCarryoverSuggestion(staff, monthKey);
  const el = document.getElementById(inputId);
  if (el) el.value = auto;
}


/* ===================== MANUAL SEARCH & REPLACEMENT ===================== */
const getShiftKeysForDate = (dateStr) => {
  const d = new Date(dateStr);
  const [y, m, day] = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
  const isWeekend = [0, 6].includes(d.getDay());
  const isHoliday = !!holidays[y]?.[toLocalISODate(new Date(y, m-1, day))];
  if (isHoliday) return Object.keys(SHIFTS).filter(k => SHIFTS[k].type === 'holiday');
  if (isWeekend) return Object.keys(SHIFTS).filter(k => SHIFTS[k].type === 'weekend');
  return Object.keys(SHIFTS).filter(k => SHIFTS[k].type === 'weekday');
};

const updateShiftOptionsForDate = async () => {
  const dateInput = document.getElementById('replaceDate');
  const shiftSel = document.getElementById('replaceShift');
  const info = document.getElementById('currentAssignmentInfo');
  info.innerHTML = '';

  const dateStr = dateInput.value;
  if (!dateStr) { shiftSel.disabled = true; shiftSel.innerHTML = ''; return; }

  try { await ensureHolidaysForYear(new Date(dateStr).getFullYear()); } catch(_) {}

  const keys = getShiftKeysForDate(dateStr);
  shiftSel.disabled = false;
  shiftSel.innerHTML = keys.map(k => `<option value="${k}">${SHIFTS[k].name} (${SHIFTS[k].time})</option>`).join('');

  const month = dateStr.substring(0,7);
  const current = scheduleData[month]?.[dateStr]?.assignments || {};
  const firstKey = keys[0];
  const curStaffId = current[firstKey] || current[shiftSel.value];
  if (curStaffId) {
    const s = staffData.find(x => x.id === curStaffId);
    if (s) info.innerHTML = `Aktuell eingetragen: <b>${s.name}</b> f√ºr ${SHIFTS[firstKey].name} ‚Äì Wechsel/Ersetzung m√∂glich.`;
  }
};

const basicAvailabilityOkay = (staff, dateStr, shiftKey) => {
  if (isStaffOnVacation(staff, dateStr)) return false;

  const d = new Date(dateStr);
  const isWeekend = [0,6].includes(d.getDay());
  const y = d.getFullYear();
  const isHoliday = !!holidays[y]?.[dateStr];
  const shiftType = SHIFTS[shiftKey].type;

  if ((isHoliday && shiftType !== 'holiday') ||
      (!isHoliday && isWeekend && shiftType !== 'weekend') ||
      (!isHoliday && !isWeekend && shiftType !== 'weekday')) return false;

  if (staff.type === 'permanent') {
    // Check if this requires overtime consent (weekends only, unless weekend preference)
    if (requiresOvertimeConsent(shiftKey, dateStr, staff.id)) {
      const consentStatus = getOvertimeConsentStatus(staff.id, dateStr, shiftKey);
      return consentStatus === 'consented';
    }

    // Regular permanent employee rules
    if (isWeekend || isHoliday) return false;
    // Evening shifts are now allowed - remove evening/closing from undesirable check
    const nonEveningUndesirable = APP_CONFIG.UNDESIRABLE_SHIFTS.filter(s => s !== 'evening' && s !== 'closing');
    if (nonEveningUndesirable.includes(shiftKey)) return false;
    const av = availabilityData[staff.id]?.[dateStr]?.[shiftKey];
    if (av === 'no') return false;
    return true;
  }

  const av = availabilityData[staff.id]?.[dateStr]?.[shiftKey];
  return av === 'yes' || av === 'prefer';
};

// Memory-efficient simulation using shallow copy and restoration
const simulateAssignmentHasBlocker = (month, dateStr, shiftKey, staffId) => {
  const originalSchedule = scheduleData[month] || {};
  const originalDay = originalSchedule[dateStr];
  const originalAssignment = originalDay?.assignments?.[shiftKey];

  // Create minimal copy for simulation
  if (!originalSchedule[dateStr]) {
    originalSchedule[dateStr] = { assignments: {}, holidayName: null };
  }
  if (!originalSchedule[dateStr].assignments) {
    originalSchedule[dateStr].assignments = {};
  }

  // Temporarily modify
  originalSchedule[dateStr].assignments[shiftKey] = staffId;

  const validated = validateSchedule(originalSchedule, month);
  const blocker = validated?.[dateStr]?.blockers?.[shiftKey] || null;

  // Restore original state
  if (originalAssignment !== undefined) {
    originalSchedule[dateStr].assignments[shiftKey] = originalAssignment;
  } else {
    delete originalSchedule[dateStr].assignments[shiftKey];
  }

  return blocker;
};

const simulateSwapHasBlocker = (month, dateStr, staffId, sourceShiftKey, targetShiftKey) => {
  const monthSchedule = JSON.parse(JSON.stringify(scheduleData[month] || {}));

  if (!monthSchedule[dateStr]) monthSchedule[dateStr] = { assignments: {} };
  if (!monthSchedule[dateStr].assignments) monthSchedule[dateStr].assignments = {};

  delete monthSchedule[dateStr].assignments[sourceShiftKey];
  monthSchedule[dateStr].assignments[targetShiftKey] = staffId;

  const validated = validateSchedule(monthSchedule, month);
  const blocker = validated?.[dateStr]?.blockers?.[targetShiftKey] || null;
  return blocker;
};

const findCandidates = () => {
  const dateStr = document.getElementById('replaceDate').value;
  const shiftKey = document.getElementById('replaceShift').value;
  const resultSel = document.getElementById('candidateSelect');
  const info = document.getElementById('currentAssignmentInfo');

  if (!dateStr || !shiftKey) {
    alert("Bitte Datum und Schicht w√§hlen.");
    return;
  }

  const month = dateStr.substring(0,7);

  const candidates = [];
  const showPermanent = document.getElementById('showPermanentOvertimeCandidates')?.checked;

  staffData.forEach(staff => {
    // If checkbox is on, allow permanent weekend candidates even without prior consent
    if (!showPermanent) {
      if (!basicAvailabilityOkay(staff, dateStr, shiftKey)) return;
    } else {
      // For permanent staff when showing overtime candidates: basic swap eligibility (date/shift allowed), vacation check
      if (staff.type === 'permanent') {
        if (!basicSwapEligibility(staff, dateStr, shiftKey)) return;
      } else {
        if (!basicAvailabilityOkay(staff, dateStr, shiftKey)) return;
      }
    }

    const blocker = simulateAssignmentHasBlocker(month, dateStr, shiftKey, staff.id);
    if (blocker) return;

    // Advisory fairness check for manual candidate listing (do not hard-block)
    const monthScheduleDraft = JSON.parse(JSON.stringify(scheduleData[month] || {}));
    if (!monthScheduleDraft[dateStr]) monthScheduleDraft[dateStr] = { assignments: {} };
    if (!monthScheduleDraft[dateStr].assignments) monthScheduleDraft[dateStr].assignments = {};
    monthScheduleDraft[dateStr].assignments[shiftKey] = staff.id;

    const weekendCounts = computeWeekendCountsForMonth(month, monthScheduleDraft);
    const currentWeekendCount = weekendCounts[staff.id] || 0;
    const isWeekendDay = [0,6].includes(new Date(dateStr).getDay());
    const exceedsMaxWeekends = (!staff.weekendPreference && currentWeekendCount > APP_CONFIG.MAX_WEEKENDS_WITHOUT_PREFERENCE);

    const av = availabilityData[staff.id]?.[dateStr]?.[shiftKey];
    const baseScore = (av === 'prefer') ? 2 : 1;

    // Mark permanent candidates without consent (weekend) with a warning tag
    const needsConsent = (staff.type === 'permanent' && requiresOvertimeConsent(shiftKey, dateStr, staff.id));
    const consentStatus = needsConsent ? getOvertimeConsentStatus(staff.id, dateStr, shiftKey) : 'consented';
    const consentWarn = (needsConsent && consentStatus !== 'consented') ? '‚ö†Ô∏è √úberstunden-Zustimmung n√∂tig' : '';

    const warnText = [
      (isWeekendDay && exceedsMaxWeekends) ? '‚ö†Ô∏è Bereits 2 Wochenenden' : '',
      consentWarn
    ].filter(Boolean).join(' | ');

    const labelWarn = warnText ? ` ${warnText}` : '';

    candidates.push({ id: staff.id, name: staff.name, type: staff.type, score: baseScore - (warnText?1:0), warn: warnText });
    return;
  });

  candidates.sort((a,b)=> b.score - a.score || a.name.localeCompare(b.name));


// Manual operation scoring/validation wrapper that treats weekend fairness as advisory
const canAssignManually = (staff, dateStr, shiftKey, weekNum, scheduledToday, daysWorkedThisWeek) => {
  // Pass isManualAssignment=true to disable hard blocks
  return canAssign(staff, dateStr, shiftKey, weekNum, scheduledToday, daysWorkedThisWeek, true);
};

  if (candidates.length === 0) {
    resultSel.innerHTML = '';
    info.innerHTML = `<span style="color:#dc3545;">Keine geeigneten Personen gefunden (Pr√ºfen Sie Verf√ºgbarkeiten/Urlaub/Regeln).</span>`;
    return;
  }
  resultSel.innerHTML = candidates.map(c => {
    const warn = c.warn ? ` ${c.warn}` : '';
    const tag = c.score===2 ? ', bevorzugt' : '';
    return `<option value="${c.id}">${c.name} (${c.type}${tag})${warn}</option>`;
  }).join('');

  // If user selected a permanent staff without consent and shift is weekend, auto-open consent modal
  const selVal = resultSel.value;
  const selected = candidates.find(c => String(c.id) === String(selVal));
  const isWeekend = [0,6].includes(new Date(dateStr).getDay());
  if (selected && isWeekend && selected.type === 'permanent') {
    const needsConsent = requiresOvertimeConsent(shiftKey, dateStr, selected.id);
    const consentStatus = getOvertimeConsentStatus(selected.id, dateStr, shiftKey);
    if (needsConsent && consentStatus !== 'consented') {
      const canBeFilled = canShiftBeFilledByRegularStaff(dateStr, shiftKey);
      if (!canBeFilled) {
        openOvertimeConsentModal(selected.id, dateStr, shiftKey, 'Unbesetzbare Schicht');
      }
    }
  }
  info.innerHTML = `Gefunden: ${candidates.length} passende Person(en).`;
};

// Open overtime consent modal
const openOvertimeConsentModal = (staffId, dateStr, shiftKey, reason = '') => {
  const staff = staffData.find(s => s.id === staffId);
  if (!staff) return;

  const template = document.getElementById('overtime-consent-modal');
  const clone = template.content.cloneNode(true);

  clone.querySelector('[data-staff-name]').textContent = staff.name;
  clone.querySelector('[data-date]').textContent = formatDateDE(dateStr);
  clone.querySelector('[data-shift-info]').textContent = `${SHIFTS[shiftKey].name} (${SHIFTS[shiftKey].time})`;
  clone.querySelector('[data-replacement-reason]').textContent = reason || 'Personalausfall';

  const closeBtn = clone.querySelector('[data-close-btn]');
  const consentBtn = clone.querySelector('[data-consent-btn]');
  const declineBtn = clone.querySelector('[data-decline-btn]');
  const cancelBtn = clone.querySelector('[data-cancel-btn]');

  closeBtn.addEventListener('click', () => closeModal('overtimeConsentModal'));
  cancelBtn.addEventListener('click', () => closeModal('overtimeConsentModal'));

  consentBtn.addEventListener('click', () => {
    handleOvertimeConsent(staffId, dateStr, shiftKey, 'consented');
    // After consent, try the assignment again
    setTimeout(() => {
      const candidateSelect = document.getElementById('candidateSelect');
      if (candidateSelect.value == staffId) {
        applyManualAssignment('assign');
      }
    }, 100);
  });

  declineBtn.addEventListener('click', () => {
    handleOvertimeConsent(staffId, dateStr, shiftKey, 'declined');
  });

  const container = document.getElementById('overtimeConsentContent');
  cleanupContainer(container);
  container.appendChild(clone);
  openModal('overtimeConsentModal');
};

// Check if a shift can be filled by regular (non-permanent) staff
const canShiftBeFilledByRegularStaff = (dateStr, shiftKey) => {
  return staffData.some(staff => {
    if (staff.type === 'permanent') return false; // Skip permanent employees
    return basicAvailabilityOkay(staff, dateStr, shiftKey);
  });
};

// Check if an evening shift can be filled by non-permanent staff
const canEveningShiftBeFilledByNonPermanent = (dateStr, shiftKey) => {
  const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
  if (!isEveningShift) return true; // Not an evening shift

  return staffData.some(staff => {
    if (staff.type === 'permanent') return false; // Skip permanent employees
    return basicAvailabilityOkay(staff, dateStr, shiftKey);
  });
};

const applyManualAssignment = (mode) => {
  const dateStr = document.getElementById('replaceDate').value;
  const shiftKey = document.getElementById('replaceShift').value;
  const candidateId = parseInt(document.getElementById('candidateSelect').value);
  if (!dateStr || !shiftKey || !candidateId) { alert("Bitte Datum, Schicht und Person w√§hlen."); return; }

  const staff = staffData.find(s => s.id === candidateId);

  // Check if permanent employee needs overtime consent (only for weekend shifts without preference)
  if (staff && staff.type === 'permanent' && requiresOvertimeConsent(shiftKey, dateStr, candidateId)) {
    const consentStatus = getOvertimeConsentStatus(candidateId, dateStr, shiftKey);
    if (consentStatus !== 'consented') {
      // Check if shift can be filled by regular staff first
      const canBeFilled = canShiftBeFilledByRegularStaff(dateStr, shiftKey);
      if (canBeFilled) {
        alert('Diese Wochenendschicht kann von regul√§ren Mitarbeitern √ºbernommen werden. √úberstunden-Anfragen sind nur bei unbesetzbaren Schichten m√∂glich.');
        return;
      }

      // Request consent only if shift cannot be filled otherwise
      requestOvertimeConsent(candidateId, dateStr, shiftKey, 'Unbesetzbare Schicht - Ersatz erforderlich');
      openOvertimeConsentModal(candidateId, dateStr, shiftKey, 'Unbesetzbare Schicht');
      return;
    }
  }

  // Check if permanent employee is being assigned to evening shift when others are available
  if (staff && staff.type === 'permanent') {
    const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
    if (isEveningShift && canEveningShiftBeFilledByNonPermanent(dateStr, shiftKey)) {
      // Check if they have reduced penalty (prefer evenings or volunteered)
      if (!hasReducedEveningPenalty(staff.id, dateStr, shiftKey)) {
        const confirmed = confirm(
          `Warnung: ${staff.name} ist festangestellt und sollte normalerweise nur Fr√ºh-/Mittagsschichten arbeiten.\n\n` +
          `Andere Mitarbeiter sind f√ºr diese Abendschicht verf√ºgbar. Trotzdem zuweisen?\n\n` +
          `Tipp: Nutzen Sie die "freiwillig"-Option in der Verf√ºgbarkeit f√ºr bevorzugte Abendschichten.`
        );
        if (!confirmed) return;
      }
    }
  }

  const month = dateStr.substring(0,7);
  if (!scheduleData[month]) scheduleData[month] = {};
  if (!scheduleData[month][dateStr]) scheduleData[month][dateStr] = { assignments: {}, holidayName: scheduleData[month][dateStr]?.holidayName || null };

  if (mode === 'sickReplace') delete scheduleData[month][dateStr].assignments[shiftKey];

  const prev = scheduleData[month][dateStr].assignments[shiftKey];
  scheduleData[month][dateStr].assignments[shiftKey] = candidateId;

  const validated = validateSchedule(scheduleData[month], month);
  const blocker = validated?.[dateStr]?.blockers?.[shiftKey] || null;

  if (blocker) {
    scheduleData[month][dateStr].assignments[shiftKey] = prev;
    alert(`Zuweisung verworfen: ${blocker}`);
    return;
  }

  scheduleData[month] = validated;

  // Update overtime credits if this was an overtime shift
  if (staff && staff.type === 'permanent' && requiresOvertimeConsent(shiftKey, dateStr, staff.id)) {
    updateOvertimeCredits(month);
  }

  saveData();
  displaySchedule();
  logAction(`${mode==='sickReplace'?'Krank/':'Manuell '}Zuweisung: ${staff?.name || '‚Äî'} am ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
  alert("Einsatz gespeichert.");
};

const isNightWeekendShift = (shiftKey) =>
  shiftKey === 'closing' || shiftKey === 'weekend-early' || shiftKey === 'weekend-late';

const getWSExceptionStatus = (weeklyTotal, weeklyNW, month) => {
  if (!APP_CONFIG.WERKSTUDENT_EXCEPTION_ENABLED) return { active: false, mode: null, ratio: 0 };
  const monthToggle = !!studentTempException[month];
  if (weeklyTotal <= APP_CONFIG.WERKSTUDENT_MAX_HOURS) {
    return { active: false, mode: null, ratio: weeklyTotal ? (weeklyNW/weeklyTotal) : 0 };
  }
  if (monthToggle) return { active: true, mode: 'ja', ratio: weeklyTotal ? (weeklyNW/weeklyTotal) : 0 };
  const ratio = weeklyTotal ? (weeklyNW / weeklyTotal) : 0;
  if (ratio >= APP_CONFIG.WERKSTUDENT_EXCEPTION_NIGHTWE_RATIO) return { active: true, mode: 'auto', ratio };
  return { active: false, mode: null, ratio };
};

const applyMinijobSteering = (score, wh, addH, shiftKey) => {
  const target = APP_CONFIG.MINIJOB_TARGET_WEEK_HOURS;
  const tol = APP_CONFIG.MINIJOB_WEEK_TOLERANCE;
  const newTotal = wh + addH;
  const dist = Math.abs(newTotal - target);
  if (dist <= tol) score += 70; else score -= APP_CONFIG.MINIJOB_STEER_PENALTY * (dist - tol);
  if (wh >= 9) score -= APP_CONFIG.MINIJOB_THIRD_SHIFT_PENALTY; // likely 3rd shift
  if (shiftKey === 'evening' && wh >= 6 && wh <= 7.5) score += APP_CONFIG.MINIJOB_TOPUP_BONUS;
  return score;
};

/* ===================== STUDENT WEEKDAY DAYTIME TRACKING ===================== */
// Helper functions for student weekday daytime shift tracking

const isWeekdayDaytimeShift = (dateStr, shiftKey) => {
  const date = new Date(dateStr);
  const dayOfWeek = date.getDay();
  const isWeekday = dayOfWeek >= 1 && dayOfWeek <= 5; // Monday-Friday
  const isDaytimeShift = shiftKey === 'early' || shiftKey === 'midday';
  return isWeekday && isDaytimeShift;
};

const getStudentWeekdayDaytimeCount = (staffId, month, weekNum) => {
  if (!studentWeekdayDaytimeShifts[month]) studentWeekdayDaytimeShifts[month] = {};
  if (!studentWeekdayDaytimeShifts[month][staffId]) studentWeekdayDaytimeShifts[month][staffId] = {};
  return studentWeekdayDaytimeShifts[month][staffId][weekNum] || 0;
};

const incrementStudentWeekdayDaytimeCount = (staffId, month, weekNum) => {
  if (!studentWeekdayDaytimeShifts[month]) studentWeekdayDaytimeShifts[month] = {};
  if (!studentWeekdayDaytimeShifts[month][staffId]) studentWeekdayDaytimeShifts[month][staffId] = {};
  studentWeekdayDaytimeShifts[month][staffId][weekNum] = (studentWeekdayDaytimeShifts[month][staffId][weekNum] || 0) + 1;
};

// Compute student weekday daytime totals for a given month directly from schedule
// Returns: { [studentId]: totalCount }
const computeStudentWeekdayDaytimeTotalsForMonth = (month, scheduleOverride = null) => {
  const schedule = scheduleOverride || (scheduleData[month] || {});
  const totals = {};
  Object.keys(schedule).forEach(dateStr => {
    const day = schedule[dateStr];
    if (!day) return;
    Object.entries(day.assignments || {}).forEach(([shiftKey, sid]) => {
      if (!sid) return;
      const staff = staffData.find(s => s.id === sid);
      if (!staff || staff.type !== 'student') return;
      if (isWeekdayDaytimeShift(dateStr, shiftKey)) {
        totals[sid] = (totals[sid] || 0) + 1;
      }
    });
  });
  return totals;
};


// Dynamic academic term detection with caching
const getAcademicTermInfo = (dateStr) => {
  // Check cache first
  if (academicTermCache[dateStr]) {
    return academicTermCache[dateStr];
  }

  const date = new Date(dateStr);
  const year = date.getFullYear();
  const month = date.getMonth() + 1; // 1-12
  const day = date.getDate();

  const config = APP_CONFIG.ACADEMIC_TERM_CONFIG;

// Compute Werkstudent exception weeks (>20h) for a given month from the schedule
// Returns: { [studentId]: exceptionWeekCount }
const computeWSExceptionWeeksForMonth = (month, scheduleOverride = null) => {
  const schedule = scheduleOverride || (scheduleData[month] || {});
  const perWeek = {}; // { sid: { weekNum: { total, nw } } }

  Object.keys(schedule).forEach(dateStr => {
    const day = schedule[dateStr];
    if (!day) return;
    const wk = getWeekNumber(new Date(dateStr));
    Object.entries(day.assignments || {}).forEach(([shiftKey, sid]) => {
      if (!sid) return;
      const staff = staffData.find(s => s.id === sid);
      if (!staff || staff.type !== 'student') return;
      if (!perWeek[sid]) perWeek[sid] = {};
      if (!perWeek[sid][wk]) perWeek[sid][wk] = { total: 0, nw: 0 };
      const h = SHIFTS[shiftKey]?.hours || 0;
      perWeek[sid][wk].total += h;
      if (isNightWeekendShift(shiftKey)) perWeek[sid][wk].nw += h;
    });
  });

  const result = {};
  Object.keys(perWeek).forEach(sid => {
    const weeks = perWeek[sid];
    let count = 0;
    Object.values(weeks).forEach(({ total /*, nw*/ }) => {
      if (total > APP_CONFIG.WERKSTUDENT_MAX_HOURS) count += 1;
    });
    result[sid] = count;
  });

  return result;
};

  let termInfo = {
    term: null,
    isInTerm: false,
    isInLecturePeriod: false,
    academicYear: null
  };

  // Determine which semester and academic year
  if (month >= config.WINTER_START_MONTH || month <= config.WINTER_END_MONTH) {
    // Winter semester spans across calendar years
    const academicYear = month >= config.WINTER_START_MONTH ? year : year - 1;
    termInfo.term = `WS${academicYear}-${academicYear + 1}`;
    termInfo.academicYear = `${academicYear}-${academicYear + 1}`;

    // Check if in winter semester period
    if (month >= config.WINTER_START_MONTH) {
      // October-December of start year
      termInfo.isInTerm = (month > config.WINTER_START_MONTH ||
                          (month === config.WINTER_START_MONTH && day >= config.WINTER_START_DAY));
    } else {
      // January-March of end year
      termInfo.isInTerm = (month < config.WINTER_END_MONTH ||
                          (month === config.WINTER_END_MONTH && day <= config.WINTER_END_DAY));
    }

    // Check if in winter lecture period
    if (termInfo.isInTerm) {
      if (month >= config.WINTER_START_MONTH) {
        // October-December: check against lecture start
        termInfo.isInLecturePeriod = (month > config.WINTER_LECTURE_START.month ||
                                     (month === config.WINTER_LECTURE_START.month && day >= config.WINTER_LECTURE_START.day));
      } else {
        // January-February: check against lecture end
        termInfo.isInLecturePeriod = (month < config.WINTER_LECTURE_END.month ||
                                     (month === config.WINTER_LECTURE_END.month && day <= config.WINTER_LECTURE_END.day));
      }
    }

  } else if (month >= config.SUMMER_START_MONTH && month <= config.SUMMER_END_MONTH) {
    // Summer semester
    termInfo.term = `SS${year}`;
    termInfo.academicYear = `${year - 1}-${year}`;

    // Check if in summer semester period
    termInfo.isInTerm = (month > config.SUMMER_START_MONTH ||
                        (month === config.SUMMER_START_MONTH && day >= config.SUMMER_START_DAY)) &&
                       (month < config.SUMMER_END_MONTH ||
                        (month === config.SUMMER_END_MONTH && day <= config.SUMMER_END_DAY));

    // Check if in summer lecture period
    if (termInfo.isInTerm) {
      termInfo.isInLecturePeriod = (month > config.SUMMER_LECTURE_START.month ||
                                   (month === config.SUMMER_LECTURE_START.month && day >= config.SUMMER_LECTURE_START.day)) &&
                                  (month < config.SUMMER_LECTURE_END.month ||
                                   (month === config.SUMMER_LECTURE_END.month && day <= config.SUMMER_LECTURE_END.day));
    }
  } else {
    // Semester break
    termInfo.term = `BREAK${year}`;
    termInfo.academicYear = `${year - 1}-${year}`;
    termInfo.isInTerm = false;
    termInfo.isInLecturePeriod = false;
  }

  // Cache the result
  academicTermCache[dateStr] = termInfo;
  saveData(); // Persist cache

  return termInfo;
};

// Backward compatibility functions
const getCurrentAcademicTerm = (dateStr) => {
  return getAcademicTermInfo(dateStr).term;
};

const isInAcademicTerm = (dateStr) => {
  return getAcademicTermInfo(dateStr).isInTerm;
};

const isInLecturePeriod = (dateStr) => {
  return getAcademicTermInfo(dateStr).isInLecturePeriod;
};

// Clean up old academic term cache entries (keep last 2 years)
const cleanupAcademicTermCache = () => {
  const currentYear = new Date().getFullYear();
  const cutoffYear = currentYear - 2;

  let cleanedCount = 0;
  Object.keys(academicTermCache).forEach(dateStr => {
    const year = parseInt(dateStr.split('-')[0]);
    if (year < cutoffYear) {
      delete academicTermCache[dateStr];
      cleanedCount++;
    }
  });

  if (cleanedCount > 0) {
    console.log(`Cleaned up ${cleanedCount} old academic term cache entries`);
    saveData();
  }
};

const getStudentExceptionWeekCount = (staffId, term) => {
  if (!studentExceptionWeeks[term]) studentExceptionWeeks[term] = {};
  return studentExceptionWeeks[term][staffId] || 0;
};

const incrementStudentExceptionWeekCount = (staffId, term) => {
  if (!studentExceptionWeeks[term]) studentExceptionWeeks[term] = {};
  studentExceptionWeeks[term][staffId] = (studentExceptionWeeks[term][staffId] || 0) + 1;
};

/* ===================== WEEKEND DISTRIBUTION TRACKING ===================== */
// Track weekend assignments per employee per month (initialized at top of file)
// Note: We track weekend DAYS worked, not individual shifts, to avoid double-counting

const getWeekendCount = (staffId, month) => {
  if (!weekendAssignments[month]) weekendAssignments[month] = {};
  return weekendAssignments[month][staffId] || 0;
};

const incrementWeekendCount = (staffId, month) => {
  if (!weekendAssignments[month]) weekendAssignments[month] = {};
  const oldCount = weekendAssignments[month][staffId] || 0;
  weekendAssignments[month][staffId] = oldCount + 1;

  const staff = staffData.find(s => s.id === staffId);
  console.log(`Weekend assignment: ${staff?.name || staffId} in ${month} - count: ${oldCount} ‚Üí ${weekendAssignments[month][staffId]}`);
};

const isWeekendShift = (dateStr, shiftKey) => {
  const date = new Date(dateStr);
  const dayOfWeek = date.getDay();
  return dayOfWeek === 0 || dayOfWeek === 6; // Sunday = 0, Saturday = 6
};


// Compute weekend counts per staff for a given month directly from scheduleData
// Counts a weekend (Sat+Sun) once per staff if they work either day
const computeWeekendCountsForMonth = (month, scheduleOverride = null) => {
  const schedule = scheduleOverride || (scheduleData[month] || {});
  const [year, monthNum] = month.split('-').map(Number);
  const daysInMonth = new Date(year, monthNum, 0).getDate();

  // Collect Saturdays for the month
  const saturdayDates = [];
  for (let day = 1; day <= daysInMonth; day++) {
    const d = new Date(year, monthNum - 1, day);
    if (d.getDay() === 6) saturdayDates.push(toLocalISODate(d));
  }

  const counts = {}; // { staffId: number }

  saturdayDates.forEach(satStr => {
    const sat = new Date(satStr);
    const sunStr = toLocalISODate(new Date(sat.getFullYear(), sat.getMonth(), sat.getDate() + 1));

    const workedThisWeekend = new Set();
    [satStr, sunStr].forEach(ds => {
      const dayData = schedule[ds];
      if (!dayData) return;
      Object.entries(dayData.assignments || {}).forEach(([shiftKey, staffId]) => {
        if (SHIFTS[shiftKey]?.type === 'weekend' && staffId) workedThisWeekend.add(staffId);
      });
    });

    workedThisWeekend.forEach(staffId => {
      counts[staffId] = (counts[staffId] || 0) + 1;
    });
  });

  return counts;
};

// Return the weekend key (Saturday date) for a given dateStr
const getWeekendKey = (dateStr) => {
  const d = new Date(dateStr);
  const dow = d.getDay();
  let sat = new Date(d);
  if (dow === 0) { // Sunday
    sat.setDate(d.getDate() - 1);
  } else if (dow === 6) {
    // already Saturday
  } else {
    return null; // not a weekend day
  }
  return toLocalISODate(sat);
};

// Check whether staff already works this weekend (Sat or Sun) in current schedule
const staffWorksThisWeekend = (staffId, month, weekendKey, scheduleOverride = null) => {
  if (!weekendKey) return false;
  const schedule = scheduleOverride || (scheduleData[month] || {});
  const satStr = weekendKey;
  const sat = new Date(satStr);
  const sunStr = toLocalISODate(new Date(sat.getFullYear(), sat.getMonth(), sat.getDate() + 1));
  let worked = false;
  [satStr, sunStr].forEach(ds => {
    const dayData = schedule[ds];
    if (!dayData) return;
    Object.entries(dayData.assignments || {}).forEach(([shiftKey, sid]) => {
      if (sid === staffId && SHIFTS[shiftKey]?.type === 'weekend') worked = true;
    });
  });
  return worked;
};

const getWeekendsInMonth = (year, monthNum) => {
  const daysInMonth = new Date(year, monthNum, 0).getDate();
  let weekendCount = 0;
  const monthName = new Date(year, monthNum - 1, 1).toLocaleDateString('de-DE', { month: 'long', year: 'numeric' });

  console.log(`Calculating weekends for ${monthName}:`);

  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, monthNum - 1, day);
    const dayOfWeek = date.getDay();
    const dayName = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'][dayOfWeek];

    // Count Saturdays as the start of each weekend
    // This gives us the actual number of weekends (Sat-Sun pairs)
    if (dayOfWeek === 6) { // Saturday
      weekendCount++;
      console.log(`  Weekend ${weekendCount}: ${day}.${monthNum} (${dayName})`);
    }
  }

  console.log(`Total weekends in ${monthName}: ${weekendCount}`);
  return weekendCount;
};

/* ===================== SCHEDULER (weekly ¬±4h, monthly ¬±2h) ===================== */
// NAVIGATION: This is the main scheduling algorithm (~600 lines)
// Key functions: generateSchedule(), scoring logic, fairness constraints

const getMonthlyToleranceFor = (staff) => {
  if (!staff) return APP_CONFIG.DEFAULT_MONTH_TOLERANCE;
  // Optional per-person override: staff.monthlyTolerance (hours)
  if (typeof staff.monthlyTolerance === 'number') return staff.monthlyTolerance;
  const byRole = APP_CONFIG.MONTH_TOLERANCE_BY_ROLE || {};
  return byRole[staff.type] ?? APP_CONFIG.DEFAULT_MONTH_TOLERANCE;
};
const generateSchedule = async () => {
  const month = document.getElementById('scheduleMonth').value;
  const [year, monthNum] = month.split('-').map(Number);
  const daysInMonth = new Date(year, monthNum, 0).getDate();

  await ensureHolidaysForYear(year);

  // --- Pre-calculation for Efficiency ---
  const monthlyTargets = {};
  const toleranceMap = {};
  staffData.forEach(s => {
    monthlyTargets[s.id] = computeMonthlyTargetWithCarryover(s, year, monthNum);
    toleranceMap[s.id] = getMonthlyToleranceFor(s);
  });

  let monthSchedule = {};
  let staffShiftCounts = {};
  let staffHoursByWeek = {};
  let monthlyHours = {};
  let staffNWHoursByWeek = {};
  let consecutiveDaysWorked = {};
  let lastShiftEndTimes = {};
  let daysWorkedThisWeek = {};
  let currentWeek = -1;

  staffData.forEach(s => {
    staffShiftCounts[s.id] = { total: 0 };
    staffHoursByWeek[s.id] = {};
    monthlyHours[s.id] = 0;
    staffNWHoursByWeek[s.id] = {};
    consecutiveDaysWorked[s.id] = 0;
    daysWorkedThisWeek[s.id] = 0;
  });

  const isOptionalEvening = (dateObj, shiftKey) => {
    const days = Array.isArray(APP_CONFIG.EVENING_OPTIONAL_DAYS) ? APP_CONFIG.EVENING_OPTIONAL_DAYS : [];
    return shiftKey === 'evening' && days.includes(dateObj.getDay());
  };

  const isShiftCritical = (date, shiftKey) => {
    const dayOfWeek = date.getDay();
    const isWeekend = [0, 6].includes(dayOfWeek);
    const dateStr = toLocalISODate(date);
    const isHoliday = !!holidays[year]?.[dateStr];

    if (isWeekend || isHoliday) {
      return APP_CONFIG.WEEKEND_SHIFTS_CRITICAL;
    }
    if (APP_CONFIG.CRITICAL_SHIFTS.includes(shiftKey)) {
      return true;
    }
    if (isOptionalEvening(date, shiftKey)) {
      return false;
    }
    if (shiftKey === 'evening') {
      return true;
    }
    return true;
  };

  const shouldConserveHours = (staff, currentDay, daysInMonth, currentMonthlyHours, monthlyTarget) => {
    if (!APP_CONFIG.HOUR_CONSERVATION_ENABLED || !staff || monthlyTarget <= 0) return false;
    const remainingDays = daysInMonth - currentDay + 1;
    const remainingHours = monthlyTarget - currentMonthlyHours;
    if (remainingHours <= 0) return true;
    const hoursPerRemainingDay = remainingHours / Math.max(1, remainingDays);
    return hoursPerRemainingDay < APP_CONFIG.HOUR_CONSERVATION_THRESHOLD;
  };

  const canAssign = (staff, dateStr, shiftKey, weekNum, scheduledToday, daysWorkedThisWeek, isManualAssignment = false) => {
    const newHours = SHIFTS[shiftKey].hours;
    const start = parseShiftTime(dateStr, SHIFTS[shiftKey].time.split('-')[0]);

    const mt = monthlyTargets[staff.id] || 0;
    const mh = monthlyHours[staff.id]  || 0;
    const tol = toleranceMap[staff.id];
    const allowedOver = Math.max(0, (mt + tol) - mh);
    if (mt > 0 && (newHours - APP_CONFIG.FLOAT_PRECISION_OFFSET) > allowedOver) {
      return { ok: false };
    }

    const isUndesirable = APP_CONFIG.UNDESIRABLE_SHIFTS.includes(shiftKey);
    const date = new Date(dateStr);
    const isWeekend = [0,6].includes(date.getDay());
    const isHoliday = !!holidays[year]?.[dateStr];

    if (scheduledToday?.has?.(staff.id)) return { ok:false };
    if ((consecutiveDaysWorked[staff.id] || 0) >= APP_CONFIG.MAX_CONSECUTIVE_DAYS) return { ok:false };
    if ((staff.type === 'student' || staff.type === 'minijob') && APP_CONFIG.FAIRNESS_ENABLED && staff.typicalWorkdays > 0 && !isManualAssignment) {
      const currentDays = daysWorkedThisWeek[staff.id] || 0;
      const typical = staff.typicalWorkdays;
      
      if (currentDays >= typical + APP_CONFIG.MAX_EXTRA_DAYS_HARD_CAP) {
        return { ok: false};
      }
      
      if (currentDays >= typical + APP_CONFIG.MAX_EXTRA_DAYS_ALLOWED) {
        if (shiftKey !== APP_CONFIG.SECOND_EXTRA_DAY_SHIFT_KEY) {
          return { ok: false };
        }
      }
    }
    
    if (isStaffOnVacation(staff, dateStr)) return { ok:false };
    if (isStaffSick(staff, dateStr)) return { ok:false };
    const lastEnd = lastShiftEndTimes[staff.id];
    if (lastEnd) {
        const restHours = (start - lastEnd) / (1000*60*60);
        const epsilon = 0.1;
        if (restHours < (APP_CONFIG.MIN_REST_HOURS - epsilon)) return { ok:false };
    }
    if (isHoliday && SHIFTS[shiftKey].type !== 'holiday') return { ok:false };
    if (!isHoliday && SHIFTS[shiftKey].type === 'holiday') return { ok:false };

    let score = 0;
    const av = availabilityData[staff.id]?.[dateStr]?.[shiftKey];
    if (staff.type === 'permanent') {
      if (requiresOvertimeConsent(shiftKey, dateStr, staff.id)) {
        const consentStatus = getOvertimeConsentStatus(staff.id, dateStr, shiftKey);
        if (consentStatus !== 'consented') return { ok: false };
        score += 50;
      } else if (isWeekend || isHoliday) {
        if (staff.weekendPreference) {
          score += APP_CONFIG.WEEKEND_PREFERENCE_BONUS;
        } else {
          return { ok: false };
        }
      }
      const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
      if (isEveningShift) {
        if (hasReducedEveningPenalty(staff.id, dateStr, shiftKey)) {
          score += 20;
        } else {
          score -= 100;
        }
      }
      if (av === 'no') return { ok:false };
      score += 60;
      if (staff.preference === shiftKey) score += 40;
    } else {
      if (!av || av === 'no') return { ok:false };
      score += 50;
      if (av === 'prefer') score += 120;
    }

    if (staff.type === 'student') {
        const termInfo = getAcademicTermInfo(dateStr);
        if (termInfo.isInTerm) {
            if (isWeekendShift(dateStr, shiftKey)) {
                score += APP_CONFIG.STUDENT_WEEKEND_BONUS;
            } else if (shiftKey === 'evening' || shiftKey === 'closing') {
                score += APP_CONFIG.STUDENT_EVENING_BONUS;
            } else if (isWeekdayDaytimeShift(dateStr, shiftKey)) {
                score += APP_CONFIG.STUDENT_WEEKDAY_DAYTIME_PENALTY_PREF;
            }
        }
    }

    if (staff.typicalWorkdays > 0) {
        const currentDays = daysWorkedThisWeek[staff.id] || 0;
        if ((staff.type === 'student' || staff.type === 'minijob') && APP_CONFIG.FAIRNESS_ENABLED) {
            if (currentDays >= staff.typicalWorkdays) {
                const monthlyProgress = mt > 0 ? (mh / mt) : 1;
                const allowsoftening = monthlyProgress < APP_CONFIG.FAIRNESS_OVERRIDE_THRESHOLD;
                if (allowsoftening) {
                  score -= 50;
                } else {
                  const basePenalty = APP_CONFIG.TYPICAL_DAYS_PENALTY;
                  const extraDays = currentDays - staff.typicalWorkdays;
                  const extraPenalty = extraDays * APP_CONFIG.EXTRA_DAY_PENALTY;
                  score -= (basePenalty + extraPenalty);
                }
              } else {
                score += 25;
              }
            }
            else {
              if (currentDays < staff.typicalWorkdays) {
                score += 15;
            } else if (currentDays >= staff.typicalWorkdays) {
                score -= 20;
            }
        }
    }

    if (mt > 0) {
      if ((mh + newHours) > mt) {
        score -= 50;
      } else {
        const gap = Math.max(0, mt - mh);
        const percentageOfTarget = mh / mt;
        let targetBonus = 0;
        if (percentageOfTarget < 0.2) targetBonus = 100;
        else if (percentageOfTarget < 0.5) targetBonus = 80;
        else if (percentageOfTarget < 0.8) targetBonus = 60;
        else targetBonus = Math.min(40, gap * 3);
        score += targetBonus;
      }
    }
    
    if (APP_CONFIG.WEEKEND_DISTRIBUTION_ENABLED && isWeekendShift(dateStr, shiftKey) && staff.type !== 'permanent') {
        const weekendCounts = computeWeekendCountsForMonth(month, monthSchedule);
        const currentWeekendCount = weekendCounts[staff.id] || 0;
        const totalWeekendsInMonth = getWeekendsInMonth(year, monthNum);
        let weekendKey = getWeekendKey(dateStr);
        if (weekendKey && weekendKey.slice(0,7) !== month) weekendKey = null;
        const alreadyWorksThisWeekend = staffWorksThisWeekend(staff.id, month, weekendKey, monthSchedule);
        const wouldAddNewWeekend = !alreadyWorksThisWeekend;
        if (staff.weekendPreference) {
            score += APP_CONFIG.WEEKEND_PREFERENCE_BONUS;
        }
        if (alreadyWorksThisWeekend) {
            score -= APP_CONFIG.WEEKEND_SATURATION_PENALTY;
        }
        if (!isManualAssignment && !staff.weekendPreference && wouldAddNewWeekend && (currentWeekendCount >= APP_CONFIG.MAX_WEEKENDS_WITHOUT_PREFERENCE)) {
            return { ok: false };
        }
        if (currentWeekendCount === 0) score += 150;
        else if (currentWeekendCount < APP_CONFIG.MIN_WEEKENDS_PER_MONTH) score += 100;
        else if (!staff.weekendPreference && currentWeekendCount >= APP_CONFIG.MAX_WEEKENDS_WITHOUT_PREFERENCE) score -= APP_CONFIG.WEEKEND_FAIRNESS_PENALTY;
        else if (currentWeekendCount >= totalWeekendsInMonth) score -= 75;
    }
    
    const curWk = staffHoursByWeek[staff.id][weekNum] || 0;
    if (staff.type === 'permanent' && staff.contractHours > 0) {
      const maxWk = staff.contractHours + APP_CONFIG.PERMANENT_HOURS_TOLERANCE;
      if (curWk + newHours > maxWk) return { ok:false };
      const minWk = staff.contractHours - APP_CONFIG.PERMANENT_HOURS_TOLERANCE;
      score += (curWk < minWk) ? 80 : 10;
    }
    
    if (staff.type === 'student') {
        const curNW = staffNWHoursByWeek[staff.id][weekNum] || 0;
        const nextTotal = curWk + newHours;
        const nextNW = curNW + (isNightWeekendShift(shiftKey) ? newHours : 0);
        const termInfo = getAcademicTermInfo(dateStr);
        if (nextTotal > APP_CONFIG.WERKSTUDENT_MAX_HOURS) {
            const { active, mode } = getWSExceptionStatus(nextTotal, nextNW, month);
            const outOfTermException = studentTempException[month] || false;
            if (outOfTermException) {
                // Allowed
            } else if (active) {
                if (termInfo.isInTerm && APP_CONFIG.STUDENT_EXCEPTION_REQUIRES_CRITICAL_SHIFT && !isShiftCritical(new Date(dateStr), shiftKey)) {
                    return { ok: false };
                }
                if (termInfo.isInTerm) {
                    const exceptionWeeksUsed = getStudentExceptionWeekCount(staff.id, termInfo.term);
                    if (exceptionWeeksUsed >= APP_CONFIG.STUDENT_MAX_EXCEPTION_WEEKS_PER_TERM) {
                        return { ok: false };
                    }
                    if (termInfo.isInLecturePeriod && exceptionWeeksUsed >= Math.floor(APP_CONFIG.STUDENT_MAX_EXCEPTION_WEEKS_PER_TERM / 2)) {
                        return { ok: false };
                    }
                }
            } else {
                return { ok: false };
            }
        }
        if (nextTotal > 16 && isNightWeekendShift(shiftKey)) score += 15;
    }

    if (staff.type === 'minijob') {
      const maxWeeklyHours = APP_CONFIG.MINIJOB_MAX_WEEK_HOURS;
      if (curWk + newHours > maxWeeklyHours) return { ok:false };
      const maxMonthlyHours = APP_CONFIG.MINIJOB_MAX_EARNING / APP_CONFIG.MINIJOB_HOURLY_WAGE;
      if (mh + newHours > maxMonthlyHours) return { ok:false };
      score = applyMinijobSteering(score, curWk, newHours, shiftKey);
    }
    if (isUndesirable) {
      score -= (staffShiftCounts[staff.id]?.total || 0) * 10;
    }
    return { ok:true, score };
  };

  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, monthNum - 1, day);
    const dateStr = toLocalISODate(date);
    const weekNum = getWeekNumber(date);
    const isWeekend = [0, 6].includes(date.getDay());
    const isHoliday = !!holidays[year]?.[dateStr];

    if (weekNum !== currentWeek) {
        currentWeek = weekNum;
        Object.keys(daysWorkedThisWeek).forEach(staffId => {
            daysWorkedThisWeek[staffId] = 0;
        });
    }
    
    let shiftsForDay = Object.keys(SHIFTS)
      .filter(key => {
        const t = SHIFTS[key].type;
        if (isHoliday) return t === 'holiday';
        return (isWeekend && t === 'weekend') || (!isWeekend && t === 'weekday');
      })
      .sort((a, b) => {
        return SHIFTS[a].time.localeCompare(SHIFTS[b].time);
      });

    const scheduledToday = new Set();
    monthSchedule[dateStr] = { assignments: {}, holidayName: isHoliday ? holidays[year][dateStr] : null };
    
    shiftsForDay.forEach(shiftKey => {
      let candidates = [];
      staffData.forEach(staff => {
        const res = canAssign(staff, dateStr, shiftKey, weekNum, scheduledToday, daysWorkedThisWeek, false);
        if (res.ok) candidates.push({ staff, score: res.score });
      });
      candidates.sort((a,b)=> b.score - a.score);
      
      if (candidates.length === 0 && isWeekend && SHIFTS[shiftKey].type === 'weekend') {
        logAction(`Wochenend-Schicht unbesetzt gelassen (Fairness-Block): ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
        return;
      }
      
      if (APP_CONFIG.STUDENT_FAIRNESS_ENABLED && candidates.length > 1) {
          // ... your student fairness override logic ...
      }
      
      if (!isShiftCritical(date, shiftKey)) {
        const conservingCandidates = candidates.filter(c => {
            const currentMonthlyHours = monthlyHours[c.staff.id] || 0;
            const monthlyTarget = monthlyTargets[c.staff.id];
            return shouldConserveHours(c.staff, day, daysInMonth, currentMonthlyHours, monthlyTarget);
        });
        if (conservingCandidates.length === candidates.length && candidates.length > 0) {
            logAction(`Optionale Schicht √ºbersprungen: ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
            return;
        }
        const nonConservingCandidates = candidates.filter(c => !conservingCandidates.includes(c));
        if (nonConservingCandidates.length > 0) {
            candidates = nonConservingCandidates;
        }
      }

      let chosenCandidate = candidates[0];
      const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
      if (isEveningShift && candidates.length > 1) {
          const nonPermanentCandidates = candidates.filter(c => c.staff.type !== 'permanent');
          if (nonPermanentCandidates.length > 0) {
              // Prioritize non-permanent staff for evening shifts
              chosenCandidate = nonPermanentCandidates[0];
              logAction(`Priorisierte Nicht-Festangestellte f√ºr Abendschicht: ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
          } else {
              // Only use permanent staff if no one else is available
              chosenCandidate = candidates[0];
              logAction(`Notfall-Zuweisung (Festangestellt): ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
          }
      }

  if (!chosenCandidate) {
    if (isOptionalEvening(date, shiftKey)) {
        logAction(`Optionale Abendschicht √ºbersprungen (keine Kandidaten): ${formatDateDE(dateStr)}`);
        return;
    }
    logAction(`Unbesetzbare Schicht: ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name}) - Keine Kandidaten gefunden.`);
    return; // Continue to the next shift in shiftsForDay.forEach
  }

      const chosen = chosenCandidate.staff;
      monthSchedule[dateStr].assignments[shiftKey] = chosen.id;
      scheduledToday.add(chosen.id);

      const hours = SHIFTS[shiftKey].hours;
      monthlyHours[chosen.id] = (monthlyHours[chosen.id] || 0) + hours;
      if (!staffHoursByWeek[chosen.id][weekNum]) staffHoursByWeek[chosen.id][weekNum] = 0;
      staffHoursByWeek[chosen.id][weekNum] += hours;
      if (!staffNWHoursByWeek[chosen.id][weekNum]) staffNWHoursByWeek[chosen.id][weekNum] = 0;
      if (isNightWeekendShift(shiftKey)) staffNWHoursByWeek[chosen.id][weekNum] += hours;
      lastShiftEndTimes[chosen.id] = parseShiftTime(dateStr, SHIFTS[shiftKey].time.split('-')[1]);
      staffShiftCounts[chosen.id].total += 1;

      if (isWeekendShift(dateStr, shiftKey)) incrementWeekendCount(chosen.id, month);
      if (chosen.type === 'student' && isWeekdayDaytimeShift(dateStr, shiftKey)) {
          incrementStudentWeekdayDaytimeCount(chosen.id, month, weekNum);
      }
      if (chosen.type === 'student') {
          const totalWeeklyHours = staffHoursByWeek[chosen.id][weekNum];
          const termInfo = getAcademicTermInfo(dateStr);
          if (totalWeeklyHours > APP_CONFIG.WERKSTUDENT_MAX_HOURS && termInfo.isInTerm) {
              if (totalWeeklyHours - hours <= APP_CONFIG.WERKSTUDENT_MAX_HOURS) {
                  incrementStudentExceptionWeekCount(chosen.id, termInfo.term);
              }
          }
      }
    });

    scheduledToday.forEach(staffId => {
        daysWorkedThisWeek[staffId] = (daysWorkedThisWeek[staffId] || 0) + 1;
    });

    staffData.forEach(s => {
      if (scheduledToday.has(s.id)) {
        consecutiveDaysWorked[s.id] = (consecutiveDaysWorked[s.id] || 0) + 1;
      } else {
        consecutiveDaysWorked[s.id] = 0;
      }
    });
  }

  monthSchedule = validateSchedule(monthSchedule, month);
  scheduleData[month] = monthSchedule;
  updateOvertimeCredits(month);
  logAction(`Dienstplan f√ºr ${month} erstellt.`);
  saveData();
  displaySchedule();
};
/* ===================== VALIDATION (warnings + blockers + badges) ===================== */
// Helper function to check if a date is the last day of the month
const isLastDayOfMonth = (dateStr, year, monthNum) => {
  const date = new Date(dateStr);
  const lastDay = new Date(year, monthNum, 0).getDate();
  return date.getDate() === lastDay;
};

// Helper function to check if a date is the last day of the week (Sunday)
const isLastDayOfWeek = (dateStr) => {
  const date = new Date(dateStr);
  return date.getDay() === 0; // Sunday = 0
};

const validateSchedule = (schedule, month) => {
  const [year, monthNum] = month.split('-').map(Number);

  let staffHoursByWeek = {};
  let staffNWHoursByWeek = {};
  let lastEndTimes = {};
  let monthlyHours = {};
  let monthlyTargets = {};

  staffData.forEach(s => {
    staffHoursByWeek[s.id] = {};
    staffNWHoursByWeek[s.id] = {};
    monthlyHours[s.id] = 0;
    monthlyTargets[s.id] = computeMonthlyTargetWithCarryover(s, year, monthNum);
  });

  let staffMonthlyEarnings = {};
  staffData.forEach(s => { staffMonthlyEarnings[s.id] = 0; });

  const dates = Object.keys(schedule).sort();
  dates.forEach(dateStr => {
    const day = schedule[dateStr];
    if (!day) return;
    day.warnings = {};
    day.badges = {};
    day.blockers = {};

    Object.entries(day.assignments || {})
      .sort((a, b) => SHIFTS[a[0]].time.localeCompare(SHIFTS[b[0]].time))
      .forEach(([shiftKey, sid]) => {
        const staff = staffData.find(s => s.id === sid);
        if (!staff) return;

        const hours = SHIFTS[shiftKey].hours;
        monthlyHours[sid] += hours;

        // --- Smart Monthly Target Validation ---
        const mt = monthlyTargets[sid] || 0;
        if (mt > 0) {
          const tol = getMonthlyToleranceFor(staff);
          const mhNow = monthlyHours[sid];
          const delta = +(mhNow - mt).toFixed(2);

          // Only warn about actual problems, not normal progression
          if (delta > tol) {
            // PROBLEM: Actually exceeding tolerance
            const amt = Math.abs(delta).toFixed(1);
            const msg = `Monatsziel √ºberschritten: ${mhNow.toFixed(1)}h > ${(mt + tol).toFixed(1)}h (Ziel: ${mt.toFixed(1)}h ¬±${tol}h)`;
            day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
            day.blockers[shiftKey] = day.blockers[shiftKey] || `Monatsziel √ºberschritten (>${(mt + tol).toFixed(1)}h).`;
          } else if (isLastDayOfMonth(dateStr, year, monthNum) && delta < -tol) {
            // PROBLEM: Will miss target by month-end
            const amt = Math.abs(delta).toFixed(1);
            const msg = `Monatsziel verfehlt: ${mhNow.toFixed(1)}h < ${(mt - tol).toFixed(1)}h (Ziel: ${mt.toFixed(1)}h ¬±${tol}h)`;
            day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
          }
          // No warning for normal progression toward target
        }

        // --- Other validation logic ---
        const wk = getWeekNumber(new Date(dateStr));
        if (!staffHoursByWeek[sid]) staffHoursByWeek[sid] = {};
        if (!staffHoursByWeek[sid][wk]) staffHoursByWeek[sid][wk] = 0;
        staffHoursByWeek[sid][wk] += hours;

        const start = parseShiftTime(dateStr, SHIFTS[shiftKey].time.split('-')[0]);
        const end = parseShiftTime(dateStr, SHIFTS[shiftKey].time.split('-')[1]);
        const lastEnd = lastEndTimes[sid];
        if (lastEnd) {
            const restHours = (start - lastEnd) / (1000 * 60 * 60);
            // Add small epsilon to handle DST transitions and floating point precision
            const epsilon = 0.1; // 6 minutes tolerance for DST edge cases
            if (restHours < (APP_CONFIG.MIN_REST_HOURS - epsilon)) {
                day.blockers[shiftKey] = `Mindest-Ruhezeit ${APP_CONFIG.MIN_REST_HOURS}h unterschritten (${restHours.toFixed(1)}h).`;
            }
        }
        lastEndTimes[sid] = end;

        if (staff.type === 'minijob') {
            const wh = staffHoursByWeek[sid][wk] || 0;
            const target = APP_CONFIG.MINIJOB_TARGET_WEEK_HOURS;
            const tolerance = APP_CONFIG.MINIJOB_WEEK_TOLERANCE;
            const maxWeekly = APP_CONFIG.MINIJOB_MAX_WEEK_HOURS;

            // Only warn about actual violations, not normal progression
            if (wh > maxWeekly) {
                const msg = `Minijob Wochenlimit √ºberschritten: ${wh.toFixed(1)}h > ${maxWeekly}h`;
                day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
            } else if (isLastDayOfWeek(dateStr) && Math.abs(wh - target) > tolerance) {
                // Only warn at end of week if significantly off target
                const delta = (wh - target).toFixed(1);
                const direction = wh > target ? '√ºberschritten' : 'unterschritten';
                const msg = `Minijob Wochenziel ${direction}: ${wh.toFixed(1)}h (Ziel: ${target}h ¬±${tolerance}h)`;
                day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
            }

            // Check monthly earning limit for minijobs
            const monthlyEarnings = monthlyHours[sid] * APP_CONFIG.MINIJOB_HOURLY_WAGE;
            const maxEarnings = APP_CONFIG.MINIJOB_MAX_EARNING;
            if (monthlyEarnings > maxEarnings) {
                const msg = `Minijob Verdienstgrenze √ºberschritten: ‚Ç¨${monthlyEarnings.toFixed(2)} > ‚Ç¨${maxEarnings} (${monthlyHours[sid].toFixed(1)}h √ó ‚Ç¨${APP_CONFIG.MINIJOB_HOURLY_WAGE})`;
                day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
            }
            // No warning for normal progression during the week/month
        }

        // Werkstudent exception badge logic
        if (staff.type === 'student') {
            if (!staffNWHoursByWeek[sid]) staffNWHoursByWeek[sid] = {};
            if (!staffNWHoursByWeek[sid][wk]) staffNWHoursByWeek[sid][wk] = 0;

            if (isNightWeekendShift(shiftKey)) {
                staffNWHoursByWeek[sid][wk] += hours;
            }

            const weeklyTotal = staffHoursByWeek[sid][wk] || 0;
            const weeklyNW = staffNWHoursByWeek[sid][wk] || 0;
            const { active, mode } = getWSExceptionStatus(weeklyTotal, weeklyNW, month);

            // Show meaningful warnings for actual violations
            if (weeklyTotal > APP_CONFIG.WERKSTUDENT_MAX_HOURS) {
                if (!active) {
                    // VIOLATION: Exceeding 20h without valid exception
                    const msg = `Werkstudent Limit √ºberschritten: ${weeklyTotal.toFixed(1)}h > ${APP_CONFIG.WERKSTUDENT_MAX_HOURS}h (keine g√ºltige Ausnahme)`;
                    day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
                } else {
                    // Show badge when exception is active and allows this assignment
                    day.badges[shiftKey] = mode === 'ja' ? 'WS' : 'WS-Auto';

                    // Optional: Show info about exception being used
                    if (mode === 'auto') {
                        const ratio = (weeklyNW / weeklyTotal * 100).toFixed(0);
                        const msg = `Werkstudent Ausnahme aktiv: ${ratio}% Nacht-/Wochenendarbeit (‚â•50% erforderlich)`;
                        day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
                    }
                }
            }

            // Check student fairness violations (typical workdays)
            if (staff.typicalWorkdays > 0) {
                // Count days worked this week up to this date
                let daysThisWeek = 0;
                const currentDate = new Date(dateStr);
                const weekStart = new Date(currentDate);
                weekStart.setDate(currentDate.getDate() - currentDate.getDay() + 1); // Monday

                for (let d = new Date(weekStart); d <= currentDate; d.setDate(d.getDate() + 1)) {
                    const checkDateStr = toLocalISODate(d);
                    if (schedule[checkDateStr]) {
                        const hasAssignment = Object.values(schedule[checkDateStr].assignments || {}).includes(sid);
                        if (hasAssignment) daysThisWeek++;
                    }
                }

                if (daysThisWeek > staff.typicalWorkdays) {
                    const msg = `√úberschreitung der gew√ºnschten Arbeitstage: ${daysThisWeek}/${staff.typicalWorkdays} Tage diese Woche`;
                    day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
                }
            }

            // Check student weekday daytime limit violations
            if (staff.type === 'student' && APP_CONFIG.STUDENT_WEEKDAY_DAYTIME_ENABLED && isWeekdayDaytimeShift(dateStr, shiftKey)) {
                const termInfo = getAcademicTermInfo(dateStr);
                if (termInfo.isInTerm) {
                    // Count weekday daytime shifts this week up to this date
                    let weekdayDaytimeCount = 0;
                    const currentDate = new Date(dateStr);
                    const weekStart = new Date(currentDate);
                    weekStart.setDate(currentDate.getDate() - currentDate.getDay() + 1); // Monday

                    for (let d = new Date(weekStart); d <= currentDate; d.setDate(d.getDate() + 1)) {
                        const checkDateStr = toLocalISODate(d);
                        if (schedule[checkDateStr]) {
                            Object.entries(schedule[checkDateStr].assignments || {}).forEach(([checkShiftKey, assignedStaffId]) => {
                                if (assignedStaffId === sid && isWeekdayDaytimeShift(checkDateStr, checkShiftKey)) {
                                    weekdayDaytimeCount++;
                                }
                            });
                        }
                    }

                    if (weekdayDaytimeCount > APP_CONFIG.STUDENT_MAX_WEEKDAY_DAYTIME_SHIFTS) {
                        const outOfTermException = studentTempException[month] || false;
                        if (!outOfTermException) {
                            const periodType = termInfo.isInLecturePeriod ? 'Vorlesungszeit' : 'Semesterzeit';
                            const msg = `√úberschreitung Wochentag-Tagschicht Limit: ${weekdayDaytimeCount}/${APP_CONFIG.STUDENT_MAX_WEEKDAY_DAYTIME_SHIFTS} w√§hrend ${periodType} (${termInfo.term})`;
                            day.warnings[shiftKey] = (day.warnings[shiftKey] ? day.warnings[shiftKey] + ' | ' : '') + msg;
                        }
                    }
                }
            }
        }
      });
  });

  // Weekend distribution validation (end of month check)
  if (APP_CONFIG.WEEKEND_DISTRIBUTION_ENABLED) {
    const [year, monthNum] = month.split('-').map(Number);
    const totalWeekendsInMonth = getWeekendsInMonth(year, monthNum);
    const lastDateOfMonth = Object.keys(schedule).sort().pop();

    if (lastDateOfMonth) {
      const lastDay = schedule[lastDateOfMonth];
      if (lastDay && !lastDay.weekendDistributionChecked) {
        // Check weekend distribution fairness for non-permanent staff only
        // Compute counts directly from schedule to avoid drift
        const weekendCounts = computeWeekendCountsForMonth(month);

        staffData.forEach(staff => {
          // Skip permanent employees - weekend requirements don't apply to them
          if (staff.type === 'permanent') return;

          const weekendCount = weekendCounts[staff.id] || 0;

          if (weekendCount < APP_CONFIG.MIN_WEEKENDS_PER_MONTH) {
            const msg = `Zu wenige Wochenenden: ${weekendCount}/${APP_CONFIG.MIN_WEEKENDS_PER_MONTH} minimum (${staff.type})`;
            if (!lastDay.warnings) lastDay.warnings = {};
            lastDay.warnings[`weekend-${staff.id}`] = msg;
          } else if (!staff.weekendPreference && weekendCount > APP_CONFIG.MAX_WEEKENDS_WITHOUT_PREFERENCE) {
            const msg = `Zu viele Wochenenden ohne Pr√§ferenz: ${weekendCount}/${APP_CONFIG.MAX_WEEKENDS_WITHOUT_PREFERENCE} maximum (${staff.type})`;
            if (!lastDay.warnings) lastDay.warnings = {};
            lastDay.warnings[`weekend-${staff.id}`] = msg;
          }
        });

        lastDay.weekendDistributionChecked = true;
      }
    }
  }

  monthHoursCache[month] = {};
  staffData.forEach(s => {
    monthHoursCache[month][s.id] = +(monthlyHours[s.id] || 0).toFixed(2);
  });

  return schedule;
};

/* ===================== SCHEDULE DISPLAY ===================== */
// NAVIGATION: Schedule rendering and UI (~400 lines)
// Key functions: displaySchedule(), createScheduleRow(), weekend/student metrics

const createScheduleRow = (date, dateStr, dayData, shiftKeys) => {
  const row = document.createElement('tr');
  const dayOfWeek = date.getDay();
  let rowClass = '';
  if (dayOfWeek === 0 || dayOfWeek === 6) rowClass = 'weekend';
  if (dayData.holidayName) rowClass = 'holiday';
  row.className = rowClass;

  // Date cell
  const dateCell = document.createElement('td');
  const holidayText = dayData.holidayName ? ` (${dayData.holidayName})` : '';
  dateCell.textContent = `${formatDateDE(dateStr)} ${date.toLocaleDateString('de-DE', { weekday: 'short' })}${holidayText}`;
  row.appendChild(dateCell);

  // Shift cells - one for each shift in order
  shiftKeys.forEach(shiftKey => {
    const cell = document.createElement('td');
    const staffId = dayData.assignments[shiftKey];
    const warn = dayData.warnings?.[shiftKey];
    const badge = dayData.badges?.[shiftKey];

    if (staffId) {
      const staff = staffData.find(s => s.id === staffId);
      const assignmentTemplate = document.getElementById('staff-assignment-template');
      const assignmentClone = assignmentTemplate.content.cloneNode(true);

      assignmentClone.querySelector('[data-staff-name]').textContent = staff ? staff.name : 'Unbekannt';

      if (badge) {
        const badgeEl = assignmentClone.querySelector('[data-badge]');
        badgeEl.textContent = badge;
        badgeEl.title = "Werkstudent-Ausnahme aktiv";
        badgeEl.style.display = 'inline';
      }

      const swapBtn = assignmentClone.querySelector('[data-swap-btn]');
      swapBtn.addEventListener('click', () => openSwapModal(dateStr, shiftKey, staffId));

      if (warn || dayData.blockers?.[shiftKey]) {
        const warningEl = assignmentClone.querySelector('[data-warning]');
        const tooltip = [
          warn ? `‚ö†Ô∏è ${warn}` : '',
          dayData.blockers?.[shiftKey] ? `‚ùå ${dayData.blockers[shiftKey]}` : ''
        ].filter(Boolean).join('\n');
        warningEl.title = tooltip;
        warningEl.style.display = 'inline';
      }

      cell.appendChild(assignmentClone);
    }

    row.appendChild(cell);
  });

  return row;
};

const displayWeekendDistribution = (month) => {
  if (!APP_CONFIG.WEEKEND_DISTRIBUTION_ENABLED || !weekendAssignments[month]) return '';

  const [year, monthNum] = month.split('-').map(Number);
  const totalWeekendsInMonth = getWeekendsInMonth(year, monthNum);

  let report = '<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">';
  report += '<h4>Wochenend-Verteilung f√ºr ' + month + '</h4>';
  report += `<p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">Gesamt: ${totalWeekendsInMonth} Wochenenden im Monat</p>`;
  report += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">';

  // Compute counts directly from schedule to avoid drift
  const weekendCounts = computeWeekendCountsForMonth(month);

  staffData.forEach(staff => {
    const weekendCount = weekendCounts[staff.id] || 0;
    const preferenceIcon = staff.weekendPreference ? '‚≠ê' : '';

    // Different status logic for permanent vs non-permanent employees
    let status;
    if (staff.type === 'permanent') {
      status = 'üîπ'; // Blue diamond for permanent (no requirements)
    } else {
      status = weekendCount < APP_CONFIG.MIN_WEEKENDS_PER_MONTH ? '‚ö†Ô∏è' :
               (!staff.weekendPreference && weekendCount > APP_CONFIG.MAX_WEEKENDS_WITHOUT_PREFERENCE) ? '‚ö†Ô∏è' : '‚úÖ';
    }

    report += `<div style="padding: 5px; border: 1px solid #ddd; border-radius: 3px;">`;
    report += `${status} ${staff.name} ${preferenceIcon}<br>`;
    report += `${weekendCount}/${totalWeekendsInMonth} Wochenenden`;
    if (staff.type === 'permanent') {
      report += `<br><small style="color: #666;">Festangestellt (keine Anforderungen)</small>`;
    }
    report += `</div>`;
  });

  report += '</div></div>';
  return report;
};

const displayStudentMetrics = (month) => {
  if (!APP_CONFIG.STUDENT_WEEKDAY_DAYTIME_ENABLED) return '';

  const [year, monthNum] = month.split('-').map(Number);
  const students = staffData.filter(s => s.type === 'student');
  if (students.length === 0) return '';

  let report = '<div style="margin: 10px 0; padding: 10px; background: #e8f4fd; border-radius: 5px;">';
  report += '<h4>Werkstudent Metriken f√ºr ' + month + '</h4>';

  // Weekday daytime usage
  report += '<div style="margin-bottom: 15px;"><h5>Wochentag-Tagschicht Nutzung</h5>';
  report += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">';

  const computedTotals = computeStudentWeekdayDaytimeTotalsForMonth(month);
  students.forEach(student => {
    const totalWeekdayDaytime = computedTotals[student.id] || 0;
    const maxWeeksInMonth = Math.ceil(new Date(year, monthNum, 0).getDate() / 7);
    const avgPerWeek = maxWeeksInMonth > 0 ? (totalWeekdayDaytime / maxWeeksInMonth).toFixed(1) : '0';

    const status = totalWeekdayDaytime > (APP_CONFIG.STUDENT_MAX_WEEKDAY_DAYTIME_SHIFTS * maxWeeksInMonth) ? '‚ö†Ô∏è' : '‚úÖ';

    report += `<div style="padding: 5px; border: 1px solid #ddd; border-radius: 3px;">`;
    report += `${status} ${student.name}<br>`;
    report += `${totalWeekdayDaytime} Tagschichten (‚åÄ${avgPerWeek}/Woche)<br>`;
    report += `<small>Limit: ${APP_CONFIG.STUDENT_MAX_WEEKDAY_DAYTIME_SHIFTS}/Woche</small>`;
    report += `</div>`;
  });

  report += '</div></div>';

  // Exception week usage with dynamic term detection
  const midMonthDate = month + '-15'; // Use mid-month date for term detection
  const termInfo = getAcademicTermInfo(midMonthDate);

  if (termInfo.isInTerm) {
    const periodType = termInfo.isInLecturePeriod ? 'Vorlesungszeit' : 'Semesterzeit';
    report += `<div><h5>Ausnahmewochen (>20h) f√ºr ${termInfo.term} (${periodType})</h5>`;
    report += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">';

    const computedExceptionWeeks = computeWSExceptionWeeksForMonth(month);

    students.forEach(student => {
      const exceptionWeeks = computedExceptionWeeks[student.id] || 0;
      const lectureLimit = Math.floor(APP_CONFIG.STUDENT_MAX_EXCEPTION_WEEKS_PER_TERM / 2);
      const currentLimit = termInfo.isInLecturePeriod ? lectureLimit : APP_CONFIG.STUDENT_MAX_EXCEPTION_WEEKS_PER_TERM;
      const status = exceptionWeeks >= currentLimit ? '‚ö†Ô∏è' : '‚úÖ';

      report += `<div style=\"padding: 5px; border: 1px solid #ddd; border-radius: 3px;\">`;
      report += `${status} ${student.name}<br>`;
      report += `${exceptionWeeks}/${currentLimit} Ausnahmewochen`;
      if (termInfo.isInLecturePeriod) {
        report += `<br><small>Vorlesungszeit-Limit: ${lectureLimit}</small>`;
      }
      report += `</div>`;
    });

    report += '</div></div>';
  } else {
    report += `<div><h5>Aktuell: ${termInfo.term} (Semesterferien)</h5>`;
    report += '<p style="color: #666; font-style: italic;">Keine Ausnahmewochenbegrenzung w√§hrend der Semesterferien.</p></div>';
  }

  report += '</div>';
  return report;
};

const displaySchedule = () => {
  const month = document.getElementById('scheduleMonth').value;
  const container = document.getElementById('scheduleContent');
  const schedule = scheduleData[month];

  if (!schedule) {
    container.innerHTML = '<p>F√ºr diesen Monat wurde noch kein Dienstplan erstellt.</p>';
    return;
  }

  const [year, monthNum] = month.split('-').map(Number);
  const daysInMonth = new Date(year, monthNum, 0).getDate();

  // Clear container
  cleanupContainer(container);

  // Create table manually for proper column alignment
  const table = document.createElement('table');
  table.className = 'schedule-table';

  // Create header
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');

  const dayHeader = document.createElement('th');
  dayHeader.textContent = 'Tag';
  headerRow.appendChild(dayHeader);

  // Add shift headers in correct order
  const shiftKeys = Object.keys(SHIFTS);
  shiftKeys.forEach(key => {
    const th = document.createElement('th');
    th.innerHTML = `${SHIFTS[key].name}<br><small>${SHIFTS[key].time}</small>`;
    headerRow.appendChild(th);
  });

  thead.appendChild(headerRow);
  table.appendChild(thead);

  // Create body
  const tbody = document.createElement('tbody');

  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, monthNum - 1, day);
    const dateStr = toLocalISODate(date);
    const dayData = schedule[dateStr] || { assignments: {}, holidayName: null };

    const row = createScheduleRow(date, dateStr, dayData, shiftKeys);
    tbody.appendChild(row);
  }

  table.appendChild(tbody);
  container.appendChild(table);

  // Add weekend distribution report
  const weekendReport = displayWeekendDistribution(month);
  if (weekendReport) {
    container.insertAdjacentHTML('beforeend', weekendReport);
  }

  // Add student metrics report
  const studentReport = displayStudentMetrics(month);
  if (studentReport) {
    container.insertAdjacentHTML('beforeend', studentReport);
  }
};

const clearSchedule = () => {
  const month = document.getElementById('scheduleMonth').value;
  if (scheduleData[month] && confirm(`Soll der Dienstplan f√ºr ${month} wirklich gel√∂scht werden?`)) {
    delete scheduleData[month];
    saveData();
    displaySchedule();
    logAction(`Dienstplan f√ºr ${month} gel√∂scht.`);
  }
};

/* ===================== REPORTS ===================== */
const getActualScheduledHours = (staffId, monthKey) => {
  const cached = monthHoursCache?.[monthKey]?.[staffId];
  if (typeof cached === 'number') return cached;

  // Fallback: compute once and fill the cache for everyone
  const sched = scheduleData[monthKey];
  if (!sched) return 0;

  const totals = {};
  Object.values(sched).forEach(day => {
    Object.entries(day.assignments || {}).forEach(([shiftKey, sid]) => {
      totals[sid] = (totals[sid] || 0) + SHIFTS[shiftKey].hours;
    });
  });

  monthHoursCache[monthKey] = {};
  staffData.forEach(s => {
    monthHoursCache[monthKey][s.id] = +(totals[s.id] || 0).toFixed(2);
  });
  saveData();

  return monthHoursCache[monthKey][staffId] || 0;
};


const generateReport = async () => {
  const month = document.getElementById('reportsMonth').value;
  const container = document.getElementById('reportsContent');
  const schedule = scheduleData[month];
  if (!schedule) {
    container.innerHTML = '<p>F√ºr diesen Monat existiert kein Dienstplan, um einen Bericht zu erstellen.</p>';
    return;
  }
  const [year, monthNum] = month.split('-').map(Number);
  await ensureHolidaysForYear(year);

  // Clear container
  cleanupContainer(container);

  const staffHours = {};
  staffData.forEach(s => staffHours[s.id] = { name: s.name, type: s.type, hours: 0 });

  Object.values(schedule).forEach(day => {
    Object.entries(day.assignments).forEach(([shiftKey, staffId]) => {
      if (staffHours[staffId]) {
        staffHours[staffId].hours += SHIFTS[shiftKey].hours;
      }
    });
  });

  // Create overview table using template
  const overviewTemplate = document.getElementById('reports-overview-template');
  const overviewClone = overviewTemplate.content.cloneNode(true);
  overviewClone.querySelector('[data-month]').textContent = month;

  const overviewTbody = overviewClone.querySelector('[data-table-body]');
  const rowTemplate = document.getElementById('reports-row-template');

  Object.values(staffHours).filter(s => s.hours > 0).forEach(s => {
    const rowClone = rowTemplate.content.cloneNode(true);
    const earnings = s.hours * APP_CONFIG.MINIJOB_HOURLY_WAGE;
    let status = '<span style="color: green;">OK</span>';
    if (s.type === 'minijob' && earnings > APP_CONFIG.MINIJOB_MAX_EARNING) {
      status = `<span style="color: red;">Limit √ºberschritten!</span>`;
    }

    rowClone.querySelector('[data-name]').textContent = s.name;
    rowClone.querySelector('[data-type]').textContent = s.type;
    rowClone.querySelector('[data-hours]').textContent = s.hours.toFixed(2);
    rowClone.querySelector('[data-earnings]').textContent = `${earnings.toFixed(2)} ‚Ç¨`;
    rowClone.querySelector('[data-status]').innerHTML = status;

    overviewTbody.appendChild(rowClone);
  });

  container.appendChild(overviewClone);

  // Generate Werkstudent overview if needed
  const wsRows = [];
  const dates = Object.keys(schedule).sort();
  const wsWeekly = {};
  staffData.filter(s=>s.type==='student').forEach(s => wsWeekly[s.id] = {});

  dates.forEach(dateStr => {
    const date = new Date(dateStr);
    const wk = getWeekNumber(date);
    const day = schedule[dateStr];
    Object.entries(day.assignments).forEach(([shiftKey, staffId]) => {
      const s = staffData.find(x=>x.id===staffId);
      if (!s || s.type!=='student') return;
      if (!wsWeekly[staffId]) wsWeekly[staffId] = {};
      if (!wsWeekly[staffId][wk]) wsWeekly[staffId][wk] = { total: 0, nw: 0 };
      wsWeekly[staffId][wk].total += SHIFTS[shiftKey].hours;
      if (isNightWeekendShift(shiftKey)) wsWeekly[staffId][wk].nw += SHIFTS[shiftKey].hours;
    });
  });

  Object.keys(wsWeekly).forEach(sid => {
    const staff = staffData.find(s=>s.id===Number(sid));
    Object.keys(wsWeekly[sid]).sort((a,b)=>a-b).forEach(wk => {
      const t = wsWeekly[sid][wk].total;
      const nw = wsWeekly[sid][wk].nw;
      const { active, mode, ratio } = getWSExceptionStatus(t, nw, month);
      const label = t > APP_CONFIG.WERKSTUDENT_MAX_HOURS ? (active ? (mode==='ja'?'ja':'auto (WE/Nacht ‚â•50%)') : 'nein') : '';
      wsRows.push({ name: staff.name, week: wk, total: t, ratio: (t? (nw/t*100):0), ex: label });
    });
  });

  if (wsRows.length) {
    const wsTemplate = document.getElementById('werkstudent-overview-template');
    const wsClone = wsTemplate.content.cloneNode(true);
    const wsTbody = wsClone.querySelector('[data-table-body]');
    const wsRowTemplate = document.getElementById('werkstudent-row-template');

    wsRows.forEach(r => {
      const wsRowClone = wsRowTemplate.content.cloneNode(true);
      wsRowClone.querySelector('[data-name]').textContent = r.name;
      wsRowClone.querySelector('[data-week]').textContent = r.week;
      wsRowClone.querySelector('[data-total]').textContent = r.total.toFixed(2);
      wsRowClone.querySelector('[data-ratio]').textContent = `${r.ratio.toFixed(0)}%`;
      wsRowClone.querySelector('[data-exception]').textContent = r.ex || '-';
      wsTbody.appendChild(wsRowClone);
    });

    container.appendChild(wsClone);
  }
};

/* ===================== MODALS / EXPORTS / LOG ===================== */
let swapContext = {};
const openModal = (id) => document.getElementById(id).style.display = 'block';
const closeModal = (id) => document.getElementById(id).style.display = 'none';

window.onclick = function(event) {
  if (event.target.classList.contains('modal')) {
    event.target.style.display = "none";
  }
};

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  // Clear any pending timeouts
  if (saveTimeout) {
    clearTimeout(saveTimeout);
    performSave(); // Final save
  }

  // Clear intervals
  if (window.memoryCleanupInterval) {
    clearInterval(window.memoryCleanupInterval);
  }
});
// --- Toast helpers with memory management ---
const ensureToastHost = () => {
  if (!document.getElementById('toastContainer')) {
    const host = document.createElement('div');
    host.id = 'toastContainer';
    document.body.appendChild(host);
  }
};

const showToast = (message, type = 'success') => {
  ensureToastHost();
  const host = document.getElementById('toastContainer');

  // Limit number of toasts to prevent memory buildup
  const maxToasts = 5;
  while (host.children.length >= maxToasts) {
    const oldestToast = host.firstChild;
    if (oldestToast) {
      oldestToast.remove();
    }
  }

  const el = document.createElement('div');
  el.className = `toast ${type}`;
  el.textContent = message;
  host.appendChild(el);

  // Use WeakRef for cleanup to prevent memory leaks
  const toastRef = new WeakRef(el);
  setTimeout(() => {
    const toast = toastRef.deref();
    if (toast && toast.parentNode) {
      toast.remove();
    }
  }, 3000);
};

/* ========= SWAP: helpers + modal (drop‚Äëin) ========= */
function parseYMDLocal(dateStr) {
  const [y, m, d] = dateStr.split('-').map(Number);
  return new Date(y, (m ?? 1) - 1, d ?? 1);
}
function getDayLocal(dateStr) {
  return parseYMDLocal(dateStr).getDay();
}

function isShiftAllowedOnDate(dateStr, shiftKey) {
  const shift = SHIFTS && SHIFTS[shiftKey];
  if (!shift) return false;

  const isWE = [0, 6].includes(getDayLocal(dateStr));
  const y = parseYMDLocal(dateStr).getFullYear();
  const isHoliday = !!(holidays && holidays[y] && holidays[y][dateStr]);
  const t = shift.type;

  if (isHoliday) return t === 'holiday';
  if (isWE) return t === 'weekend';
  return t === 'weekday';
}

function basicSwapEligibility(staff, dateStr, shiftKey) {
  if (!isShiftAllowedOnDate(dateStr, shiftKey)) return false;
  if (typeof isStaffOnVacation === 'function' && isStaffOnVacation(staff, dateStr)) return false;

  const isWE = [0, 6].includes(getDayLocal(dateStr));
  const y = parseYMDLocal(dateStr).getFullYear();
  const isHoliday = !!(holidays && holidays[y] && holidays[y][dateStr]);
  const undesirable = Array.isArray(APP_CONFIG?.UNDESIRABLE_SHIFTS) && APP_CONFIG.UNDESIRABLE_SHIFTS.includes(shiftKey);
  const av = availabilityData?.[staff.id]?.[dateStr]?.[shiftKey];

  if (staff.type === 'permanent') {
    // Check if this requires overtime consent (weekends only, unless weekend preference)
    if (requiresOvertimeConsent(shiftKey, dateStr, staff.id)) {
      const consentStatus = getOvertimeConsentStatus(staff.id, dateStr, shiftKey);
      return consentStatus === 'consented';
    }

    // Regular permanent employee rules
    if (isWE || isHoliday) return false;
    // Allow evening shifts but they should be discouraged
    const isEveningShift = shiftKey === 'evening' || shiftKey === 'closing';
    if (undesirable && !isEveningShift) return false;
    if (av === 'no') return false;

    // For evening shifts, check if non-permanent staff could handle it instead
    if (isEveningShift && canEveningShiftBeFilledByNonPermanent(dateStr, shiftKey)) {
      // Still eligible but should be discouraged in favor of non-permanent staff
      return true;
    }

    return true;
  }
  return av === 'yes' || av === 'prefer';
}

/* build candidate list; now handles same-day swap candidates correctly */
function getSwapCandidates(dateStr, shiftKey, { enforceRules = true } = {}) {
  const month = dateStr.slice(0, 7);
  const assignmentsToday = scheduleData?.[month]?.[dateStr]?.assignments || {};

  const list = staffData.filter(staff => {
    // Basic checks for availability, vacation, etc.
    if (!basicSwapEligibility(staff, dateStr, shiftKey)) return false;

    if (enforceRules && typeof simulateAssignmentHasBlocker === 'function') {
      const isAlreadyWorkingToday = Object.values(assignmentsToday).includes(staff.id);

      // For a potential two-way swap, we skip the simple simulation.
      // The intelligent validation will happen later in executeSwap().
      if (isAlreadyWorkingToday) {
        return true; // Add them to the list for consideration.
      }

      // For a simple replacement, run the standard simulation.
      const blocker = simulateAssignmentHasBlocker(month, dateStr, shiftKey, staff.id);
      if (blocker) return false;
    }
    return true;
  });

  // order: prefer > yes/permanent > name
  return list
    .map(s => {
      const av = availabilityData?.[s.id]?.[dateStr]?.[shiftKey];
      let score = 0;
      if (av === 'prefer') score = 2;
      else if (av === 'yes' || s.type === 'permanent') score = 1;
      return { s, score };
    })
    .sort((a, b) => b.score - a.score || a.s.name.localeCompare(b.s.name))
    .map(x => x.s);
}

function openSwapModal(dateStr, shiftKey, currentStaffId) {
  swapContext = { dateStr, shiftKey, currentStaffId };

  const select = document.getElementById('swapStaffSelect');
  const currentStaff = staffData.find(s => s.id === currentStaffId);
  const shiftName = SHIFTS?.[shiftKey]?.name || shiftKey;
  document.getElementById('swapModalTitle').innerText =
    `Tausche ${shiftName} am ${formatDateDE(dateStr)} (${currentStaff?.name || '‚Äî'})`;

  let strict = getSwapCandidates(dateStr, shiftKey, { enforceRules: true })
    .filter(s => s.id !== currentStaffId);

  let soft = [];
  if (!strict.length) {
    soft = getSwapCandidates(dateStr, shiftKey, { enforceRules: false })
      .filter(s => s.id !== currentStaffId);
  }

  if (strict.length) {
    select.innerHTML =
      `<optgroup label="Verf√ºgbar">` +
      strict.map(s => {
        const av = availabilityData?.[s.id]?.[dateStr]?.[shiftKey];
        const tag = av === 'prefer' ? ' ‚òÜ' : '';
        return `<option value="${s.id}">${s.name} (${s.type})${tag}</option>`;
      }).join('') +
      `</optgroup>`;
  } else if (soft.length) {
    select.innerHTML =
      `<optgroup label="Pr√ºfen (Regeln evtl. verletzt)">` +
      soft.map(s => `<option value="${s.id}">${s.name} (${s.type}) ‚ö†Ô∏é pr√ºfen</option>`).join('') +
      `</optgroup>`;
  } else {
    select.innerHTML = `<option disabled>Keine geeigneten Personen</option>`;
  }

  openModal('swapModal');
}

const reportSick = () => {
  const { dateStr, shiftKey, currentStaffId } = swapContext;
  const month = dateStr.substring(0, 7);
  delete scheduleData[month][dateStr].assignments[shiftKey];
  const staff = staffData.find(s => s.id === currentStaffId);
  scheduleData[month] = validateSchedule(scheduleData[month], month);
  logAction(`Krankmeldung: ${staff?.name || '‚Äî'} am ${formatDateDE(dateStr)} (${SHIFTS[shiftKey].name})`);
  saveData();
  displaySchedule();
  closeModal('swapModal');
};

const exportSchedule = (format) => {
  const month = document.getElementById('scheduleMonth').value;
  if (!scheduleData[month]) return alert("Bitte zuerst einen Dienstplan erstellen.");
  if (format === 'csv') exportToCSV(month);
  if (format === 'pdf') exportToPDF(month);
};
const exportToCSV = (month) => {
  const [year, monthNum] = month.split('-').map(Number);
  let rows = [];
  rows.push(['Tag', ...Object.values(SHIFTS).map(s => `${s.name} (${s.time})`)].join(';'));
  for (let day = 1; day <= new Date(year, monthNum, 0).getDate(); day++) {
    const date = new Date(year, monthNum - 1, day);
    const dateStr = toLocalISODate(date);
    const dayData = scheduleData[month][dateStr] || { assignments: {} , holidayName: null };
    const holidayNote = dayData.holidayName ? ` [Feiertag: ${dayData.holidayName}]` : '';
    const row = [`${formatDateDE(dateStr)} (${date.toLocaleDateString('de-DE', { weekday: 'short' })})${holidayNote}`];
    Object.keys(SHIFTS).forEach(shiftKey => {
      const staffId = dayData.assignments[shiftKey];
      row.push(staffId ? (staffData.find(s => s.id === staffId)?.name || '') : '');
    });
    rows.push(row.join(';'));
  }
  const blob = new Blob([`\uFEFF${rows.join('\n')}`], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `Dienstplan_${month}.csv`;

  // Ensure cleanup happens even if click fails
  try {
    a.click();
  } finally {
    // Cleanup URL object immediately after use
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  logAction(`CSV f√ºr ${month} exportiert.`);
};
const exportToPDF = (month) => {
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4', compress: true });

  const [year, monthNum] = month.split('-').map(Number);
  const pageW = doc.internal.pageSize.getWidth();
  const pageH = doc.internal.pageSize.getHeight();

  const bottomBoxHeight = 42;
  const margins = { top: 12, right: 8, bottom: bottomBoxHeight + 6, left: 8 };

  const weekdayCols = [
    { key: 'early',  label: 'Fr√ºh\n06:45‚Äì12:00' },
    { key: 'midday', label: 'Mittel\n11:45‚Äì17:00' },
    { key: 'evening',label: 'Abend\n17:00‚Äì20:30' },
    { key: 'closing',label: 'Sp√§t\n16:45‚Äì22:15' },
  ];
  const weekendCols = [
    { key: 'weekend-early', label: 'WE Fr√ºh\n08:45‚Äì14:35' },
    { key: 'weekend-late',  label: 'WE Sp√§t\n14:25‚Äì20:15' },
  ];
  const holidayCols = [
    { key: 'holiday-early', label: 'FT Fr√ºh\n08:45‚Äì13:15' },
    { key: 'holiday-late',  label: 'FT Sp√§t\n13:05‚Äì17:15' },
  ];

  const head = [[ 'Tag', 'Schicht 1', 'Schicht 2', 'Schicht 3', 'Schicht 4' ]];
  const daysInMonth = new Date(year, monthNum, 0).getDate();
  const body = [];
  const rowTypes = [];

  const getStaffName = (dayData, key) => {
    const sid = dayData?.assignments?.[key];
    if (!sid) return '‚Äî';
    const s = staffData.find(x => x.id === sid);
    return s ? s.name : '‚Äî';
  };
  const makeCell = (label, name) => `${label}\n${name}`;

  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, monthNum - 1, day);
    const dateStr = toLocalISODate(date);
    const isWeekend = [0, 6].includes(date.getDay());
    const isHoliday = !!holidays[year]?.[dateStr];

    const dayData = (scheduleData[month] && scheduleData[month][dateStr]) || { assignments: {}, holidayName: null };
    const holidayNote = dayData?.holidayName ? ` [Feiertag: ${dayData.holidayName}]` : '';
    const dayCell = `${formatDateDE(dateStr)} (${date.toLocaleDateString('de-DE', { weekday: 'short' })})${holidayNote}`;

    if (isHoliday) {
      const cells = holidayCols.map(c => makeCell(c.label, getStaffName(dayData, c.key)));
      cells.push({ content: '', colSpan: 2 });
      body.push([dayCell, ...cells]);
      rowTypes.push('holiday');
    } else if (isWeekend) {
      const cells = weekendCols.map(c => makeCell(c.label, getStaffName(dayData, c.key)));
      cells.push({ content: '', colSpan: 2 });
      body.push([dayCell, ...cells]);
      rowTypes.push('weekend');
    } else {
      const cells = weekdayCols.map(c => makeCell(c.label, getStaffName(dayData, c.key)));
      body.push([dayCell, ...cells]);
      rowTypes.push('weekday');
    }
  }

  doc.setFontSize(12);
  doc.text(`Dienstplan f√ºr ${month}`, margins.left, margins.top - 3);

  const tableStartY = margins.top + 2;

  doc.autoTable({
    head,
    body,
    startY: tableStartY,
    theme: 'grid',
    margin: { top: margins.top, right: margins.right, bottom: margins.bottom, left: margins.left },
    styles: { fontSize: 7, cellPadding: 1.2, valign: 'middle' },
    headStyles: { fillColor: [44, 62, 80], textColor: 255 },
    columnStyles: {
      0: { cellWidth: 42 },
      1: { cellWidth: 40 },
      2: { cellWidth: 40 },
      3: { cellWidth: 40 },
      4: { cellWidth: 40 },
    },
    didParseCell: (data) => {
      if (data.section === 'body') {
        const rowType = rowTypes[data.row.index];
        if (rowType === 'holiday') {
          data.cell.styles.fillColor = [255, 243, 205];
          data.cell.styles.fontStyle = 'bold';
        } else if (rowType === 'weekend') {
          data.cell.styles.fillColor = [240, 248, 255];
        }
        if (data.column.index > 0) data.cell.styles.lineHeight = 0.92;
      }
    },
    willDrawCell: (data) => {
      const endY = doc.lastAutoTable.finalY || tableStartY;
      const available = pageH - margins.bottom - tableStartY;
      if (endY - tableStartY > available) {
        if (!exportToPDF._shrunk) {
          exportToPDF._shrunk = true;
          doc.setPage(1);
          doc.setFontSize(12);
          doc.text(`Dienstplan f√ºr ${month}`, margins.left, margins.top - 3);
          doc.autoTable({
            head, body,
            startY: tableStartY,
            theme: 'grid',
            margin: { top: margins.top, right: margins.right, bottom: margins.bottom, left: margins.left },
            styles: { fontSize: 6.5, cellPadding: 1.0, valign: 'middle' },
            headStyles: { fillColor: [44, 62, 80], textColor: 255 },
            columnStyles: { 0: { cellWidth: 38 }, 1: { cellWidth: 38 }, 2: { cellWidth: 38 }, 3: { cellWidth: 38 }, 4: { cellWidth: 38 }, },
            didParseCell: (d) => {
              if (d.section === 'body') {
                const rowType2 = rowTypes[d.row.index];
                if (rowType2 === 'holiday') {
                  d.cell.styles.fillColor = [255, 243, 205];
                  d.cell.styles.fontStyle = 'bold';
                } else if (rowType2 === 'weekend') {
                  d.cell.styles.fillColor = [240, 248, 255];
                }
                if (d.column.index > 0) d.cell.styles.lineHeight = 0.9;
              }
            }
          });
        }
      }
    }
  });

  const boxTop = pageH - bottomBoxHeight + 4;
  const boxLeft = margins.left;
  const boxWidth = pageW - margins.left - margins.right;
  const boxHeight = bottomBoxHeight - 8;

  const monthStart = new Date(year, monthNum - 1, 1);
  const monthEnd = new Date(year, monthNum - 1, daysInMonth);

  const overlaps = (startStr, endStr) => {
    const s = new Date(startStr);
    const e = new Date(endStr);
    if (isNaN(s) || isNaN(e)) return false;
    return s <= monthEnd && e >= monthStart;
  };

  const vacationLines = [];
  staffData.forEach(s => {
    (s.vacations || []).forEach(v => {
      if (overlaps(v.start, v.end)) {
        const start = new Date(v.start) < monthStart ? monthStart : new Date(v.start);
        const end   = new Date(v.end)   > monthEnd   ? monthEnd   : new Date(v.end);
        const sText = formatDateDE(toLocalISODate(start));
        const eText = formatDateDE(toLocalISODate(end));
        vacationLines.push(`${s.name}: ${sText} ‚Äì ${eText}`);
      }
    });
  });
  (otherStaffData || []).forEach(s => {
    (s.vacations || []).forEach(v => {
      if (overlaps(v.start, v.end)) {
        const start = new Date(v.start) < monthStart ? monthStart : new Date(v.start);
        const end   = new Date(v.end)   > monthEnd   ? monthEnd   : new Date(v.end);
        vacationLines.push(`${s.name}: ${formatDateDE(toLocalISODate(start))} ‚Äì ${formatDateDE(toLocalISODate(end))}`);
      }
    });
  });

  const seen = new Set();
  const uniqVacations = vacationLines.filter(l => (seen.has(l) ? false : (seen.add(l), true)));

  doc.setDrawColor(200);
  doc.setFillColor(248, 249, 250);
  doc.roundedRect(boxLeft, boxTop, boxWidth, boxHeight, 2, 2, 'FD');

  doc.setTextColor(33);
  doc.setFontSize(10);
  doc.text('Urlaube (diesen Monat):', boxLeft + 3, boxTop + 6);

  doc.setFontSize(9);
  const lineStartY = boxTop + 11;
  const lineGap = 5;
  const maxLines = Math.floor((boxHeight - 12) / lineGap);

  uniqVacations.slice(0, maxLines).forEach((txt, i) => {
    const y = lineStartY + i * lineGap;
    doc.text(`‚Ä¢ ${txt}`, boxLeft + 5, y);
  });

  const used = Math.min(uniqVacations.length, maxLines);
  const blanks = Math.max(0, maxLines - used);
  for (let i = 0; i < blanks; i++) {
    const y = lineStartY + (used + i) * lineGap;
    doc.setDrawColor(210);
    doc.line(boxLeft + 10, y + 1, boxLeft + boxWidth - 6, y + 1);
  }

  doc.save(`Dienstplan_${month}.pdf`);
  logAction(`PDF (Portrait, 1 Seite, Urlaubsfeld) f√ºr ${month} exportiert.`);
  exportToPDF._shrunk = false;
};

const displayLog = () => {
  const container = document.getElementById('logContent');

  // Clear container
  cleanupContainer(container);

  const template = document.getElementById('log-table-template');
  const clone = template.content.cloneNode(true);
  const tbody = clone.querySelector('[data-table-body]');

  auditLog.forEach(entry => {
    const row = document.createElement('tr');
    const timestampCell = document.createElement('td');
    const actionCell = document.createElement('td');

    const timestamp = `${formatDateDE(entry.timestamp.substring(0,10))} ${new Date(entry.timestamp).toLocaleTimeString('de-DE')}`;
    timestampCell.textContent = timestamp;
    actionCell.textContent = entry.description;

    row.appendChild(timestampCell);
    row.appendChild(actionCell);
    tbody.appendChild(row);
  });

  container.appendChild(clone);
};
const isStaffOnVacation = (staff, dateStr) => (staff.vacations || []).some(v => dateStr >= v.start && dateStr <= v.end);
const isStaffSick = (staff, dateStr) => (staff.illnessPeriods || []).some(p => dateStr >= p.start && dateStr <= p.end);

const populateMonthSelectors = () => {
  const selects = ['availabilityMonth', 'scheduleMonth', 'reportsMonth'];
  const today = new Date();
  const currentMonthValue = today.toISOString().substring(0, 7);

  selects.forEach(id => {
    const selectEl = document.getElementById(id);
    selectEl.innerHTML = '';
    for (let i = -2; i < 6; i++) {
      const date = new Date(today.getFullYear(), today.getMonth() + i, 1);
      const monthValue = toLocalISOMonth(date);
      const monthName = date.toLocaleDateString('de-DE', { month: 'long', year: 'numeric' });
      const option = document.createElement('option');
      option.value = monthValue;
      option.textContent = monthName;
      if (monthValue === currentMonthValue) option.selected = true;
      selectEl.appendChild(option);
    }
  });
};
const populateYearSelector = () => {
    const select = document.getElementById('vacationYearSelect');
    if (!select) return;
    const currentYear = new Date().getFullYear();
    select.innerHTML = '';
    for (let i = -1; i <= 2; i++) {
        const year = currentYear + i;
        const option = document.createElement('option');
        option.value = year;
        option.textContent = year;
        if (year === currentYear) option.selected = true;
        select.appendChild(option);
    }
};

const countPlannedVacationDays = (staff, year) => {
    let vacationWorkdays = 0;
    (staff.vacations || []).forEach(vac => {
        const start = new Date(vac.start);
        const end = new Date(vac.end);
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
            if (d.getFullYear() === year && ![0, 6].includes(d.getDay())) {
                vacationWorkdays++;
            }
        }
    });
    return vacationWorkdays;
};

const countPlannedSickDays = (staff, year) => {
    let sickWorkdays = 0;
    (staff.illnessPeriods || []).forEach(p => {
        const start = new Date(p.start);
        const end = new Date(p.end);
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
            if (d.getFullYear() === year && ![0, 6].includes(d.getDay())) {
                sickWorkdays++;
            }
        }
    });
    return sickWorkdays;
};

const saveManualVacationDays = (staffId, year) => {
    const input = document.getElementById(`taken-days-${staffId}-${year}`);
    if (!input) return;
    const takenDays = parseInt(input.value) || 0;

    if (!vacationLedger[year]) vacationLedger[year] = {};
    if (!vacationLedger[year][staffId]) vacationLedger[year][staffId] = {};
    vacationLedger[year][staffId].taken = takenDays;

    saveData();
    showToast('Gespeichert!', 'success');
    displayVacationLedger(); // Refresh the view to update "Remaining"
};

const displayVacationLedger = () => {
    populateYearSelector();
    const year = parseInt(document.getElementById('vacationYearSelect').value);
    const container = document.getElementById('vacationLedgerContent');

    // Clear container
    cleanupContainer(container);

    // Create table using template
    const template = document.getElementById('vacation-ledger-template');
    const clone = template.content.cloneNode(true);
    const tbody = clone.querySelector('[data-table-body]');
    const rowTemplate = document.getElementById('vacation-ledger-row-template');

    staffData.forEach(staff => {
        const fullTimeAllowance = APP_CONFIG.FULL_TIME_VACATION_DAYS || 30;
        const workdays = staff.typicalWorkdays || (staff.type === 'permanent' ? 5 : 0);
        const allowance = workdays > 0 ? Math.round((fullTimeAllowance / 5) * workdays) : 0;

        if (!vacationLedger[year]) vacationLedger[year] = {};
        if (!vacationLedger[year][staff.id]) vacationLedger[year][staff.id] = { allowance: 0, taken: 0 };
        vacationLedger[year][staff.id].allowance = allowance;

        const takenManually = vacationLedger[year][staff.id].taken || 0;
        const plannedVacation = countPlannedVacationDays(staff, year);
        const remainingVacation = allowance - takenManually - plannedVacation;
        const sickDaysThisYear = countPlannedSickDays(staff, year);

        const rowClone = rowTemplate.content.cloneNode(true);

        rowClone.querySelector('[data-staff-info]').textContent = `${staff.name} (${staff.type})`;
        rowClone.querySelector('[data-allowance]').textContent = allowance;

        const inputContainer = rowClone.querySelector('[data-taken-input]');
        const input = document.createElement('input');
        input.type = 'number';
        input.style.maxWidth = '80px';
        input.id = `taken-days-${staff.id}-${year}`;
        input.value = takenManually;
        input.placeholder = 'Tage';
        inputContainer.appendChild(input);

        rowClone.querySelector('[data-planned]').textContent = plannedVacation;
        rowClone.querySelector('[data-remaining]').innerHTML = `<b>${remainingVacation}</b>`;
        rowClone.querySelector('[data-sick-days]').textContent = sickDaysThisYear;

        const buttonContainer = rowClone.querySelector('[data-action-button]');
        const button = document.createElement('button');
        button.className = 'btn btn-secondary';
        button.textContent = 'Speichern';
        button.addEventListener('click', () => saveManualVacationDays(staff.id, year));
        buttonContainer.appendChild(button);

        tbody.appendChild(rowClone);
    });

    container.appendChild(clone);
};


/* ===================== WS Toggle (UI) ===================== */
const onScheduleMonthChange = () => {
  const month = document.getElementById('scheduleMonth').value;
  const toggle = document.getElementById('wsTempExceptionToggle');
  toggle.checked = !!studentTempException[month];
  displaySchedule();
};
const toggleStudentTempException = () => {
  const month = document.getElementById('scheduleMonth').value;
  const on = document.getElementById('wsTempExceptionToggle').checked;
  studentTempException[month] = on;
  saveData();
  logAction(`Werkstudent Kurzfristige Ausnahme f√ºr ${month}: ${on ? 'aktiv' : 'inaktiv'}.`);
  if (scheduleData[month]) {
    scheduleData[month] = validateSchedule(scheduleData[month], month);
    saveData();
    displaySchedule();
  }
};

const toggleStudentFairness = () => {
  const on = document.getElementById('studentFairnessToggle').checked;
  APP_CONFIG.FAIRNESS_ENABLED = on;
  saveData();
  logAction(`Werkstudent Fairness-Modus: ${on ? 'aktiv' : 'inaktiv'} (gew√ºnschte Arbeitstage werden ${on ? 'respektiert' : 'ignoriert'}).`);

  // Re-validate current schedule if it exists
  const month = document.getElementById('scheduleMonth').value;
  if (scheduleData[month]) {
    scheduleData[month] = validateSchedule(scheduleData[month], month);
    saveData();
    displaySchedule();
  }
};

const executeSwap = () => {
  const { dateStr, shiftKey: targetShiftKey, currentStaffId: originalStaffId } = swapContext;
  const newStaffId = parseInt(document.getElementById('swapStaffSelect').value);

  if (!newStaffId || isNaN(newStaffId)) {
    return alert("Bitte eine Person zum Tauschen ausw√§hlen.");
  }

  const month = dateStr.substring(0, 7);
  const assignmentsToday = scheduleData[month]?.[dateStr]?.assignments || {};

  const newStaffsCurrentShiftKey = Object.keys(assignmentsToday).find(
    key => assignmentsToday[key] === newStaffId
  );

  let blocker;
  if (newStaffsCurrentShiftKey) {
    const blockerA = simulateSwapHasBlocker(month, dateStr, newStaffId, newStaffsCurrentShiftKey, targetShiftKey);
    const blockerB = simulateSwapHasBlocker(month, dateStr, originalStaffId, targetShiftKey, newStaffsCurrentShiftKey);

    if (blockerA || blockerB) {
      const staffA = staffData.find(s=>s.id === newStaffId)?.name;
      const staffB = staffData.find(s=>s.id === originalStaffId)?.name;
      let message = "Tausch ung√ºltig:\n";
      if (blockerA) message += `‚Ä¢ ${staffA} kann die Schicht nicht √ºbernehmen: ${blockerA}\n`;
      if (blockerB) message += `‚Ä¢ ${staffB} kann die Schicht nicht √ºbernehmen: ${blockerB}`;
      blocker = message;
    }
  } else {
    blocker = simulateAssignmentHasBlocker(month, dateStr, targetShiftKey, newStaffId);
  }

  if (blocker) {
    return alert(`Tausch nicht m√∂glich:\n${blocker}`);
  }

  const originalStaffName = staffData.find(s => s.id === originalStaffId)?.name || 'Unbekannt';
  const newStaffName = staffData.find(s => s.id === newStaffId)?.name || 'Unbekannt';

  if (newStaffsCurrentShiftKey) {
    scheduleData[month][dateStr].assignments[targetShiftKey] = newStaffId;
    scheduleData[month][dateStr].assignments[newStaffsCurrentShiftKey] = originalStaffId;
    logAction(`Schicht-Tausch: ${originalStaffName} (${SHIFTS[targetShiftKey].name}) ‚ÜîÔ∏è ${newStaffName} (${SHIFTS[newStaffsCurrentShiftKey].name}) am ${formatDateDE(dateStr)}`);
  } else {
    scheduleData[month][dateStr].assignments[targetShiftKey] = newStaffId;
    logAction(`Schicht √ºbernommen: ${newStaffName} ersetzt ${originalStaffName} am ${formatDateDE(dateStr)} (${SHIFTS[targetShiftKey].name})`);
  }

  scheduleData[month] = validateSchedule(scheduleData[month], month);

  // Update overtime credits if permanent employees were involved
  const originalStaff = staffData.find(s => s.id === originalStaffId);
  const newStaff = staffData.find(s => s.id === newStaffId);
  if ((originalStaff?.type === 'permanent') || (newStaff?.type === 'permanent')) {
    updateOvertimeCredits(month);
  }

  saveData();
  displaySchedule();
  closeModal('swapModal');
};
</script>
</body>
</html>
